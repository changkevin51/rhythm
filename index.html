<!doctype html>
<html lang="en">
<head>
    <title>Wave Rhythm - Ocean-themed Musical Experience</title>
    <meta charset="UTF-8">
    <meta name="description" content="A wave-themed 4-key rhythm game with flowing animations and oceanic visuals">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Exo+2:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Exo 2', sans-serif;
            background: linear-gradient(135deg, #001122 0%, #003366 30%, #006699 70%, #0099CC 100%);
            color: white;
            overflow: hidden;
            height: 100vh;
            position: relative;
        }
        
        /* Wave background animation */
        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 80%, rgba(0, 255, 200, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(0, 180, 255, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 50% 50%, rgba(0, 120, 200, 0.1) 0%, transparent 70%);
            animation: waveFloat 10s ease-in-out infinite;
            pointer-events: none;
            z-index: 0;
        }
        
        @keyframes waveFloat {
            0%, 100% { opacity: 0.4; transform: translateY(0px) scale(1); }
            50% { opacity: 0.8; transform: translateY(-30px) scale(1.1); }
        }

        .background-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }

        .particle {
            position: absolute;
            width: 3px;
            height: 3px;
            background: rgba(0, 180, 255, 0.8);
            border-radius: 50%;
            animation: waveParticle 12s infinite ease-in-out;
        }

        @keyframes waveParticle {
            0%, 100% { 
                transform: translateY(100vh) translateX(0px) rotate(0deg); 
                opacity: 0; 
                background: rgba(0, 180, 255, 0.6);
            }
            10% { opacity: 1; }
            50% { 
                background: rgba(0, 255, 170, 0.8);
                transform: translateY(50vh) translateX(20px) rotate(180deg);
            }
            90% { opacity: 1; }
            100% { 
                transform: translateY(-10vh) translateX(0px) rotate(360deg); 
                opacity: 0; 
                background: rgba(0, 120, 200, 0.4);
            }
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            padding: 20px;
            position: relative;
            z-index: 1;
        }

        .title {
            font-family: 'Orbitron', monospace;
            font-size: 4rem;
            font-weight: 900;
            text-align: center;
            margin-bottom: 2rem;
            background: linear-gradient(45deg, #00CCFF, #00FFAA, #0080FF);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: waveGradient 4s ease-in-out infinite;
            text-shadow: 0 0 30px rgba(0, 180, 255, 0.6);
            position: relative;
        }

        .title::after {
            content: 'Wave Rhythm';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(45deg, rgba(0, 255, 170, 0.3), rgba(0, 180, 255, 0.3));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: waveShimmer 3s ease-in-out infinite;
            z-index: -1;
        }

        @keyframes waveGradient {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        @keyframes waveShimmer {
            0%, 100% { opacity: 0.3; transform: translateX(0px); }
            50% { opacity: 0.6; transform: translateX(5px); }
        }

        .subtitle {
            font-size: 1.2rem;
            color: #80E0FF;
            text-align: center;
            margin-bottom: 3rem;
            opacity: 0.9;
            text-shadow: 0 0 15px rgba(0, 180, 255, 0.4);
        }

        .menu-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            max-width: 1200px;
            width: 100%;
        }

        .song-card {
            background: rgba(0, 60, 100, 0.15);
            border: 2px solid rgba(0, 180, 255, 0.3);
            border-radius: 20px;
            padding: 1.5rem;
            text-decoration: none;
            color: white;
            transition: all 0.4s ease;
            backdrop-filter: blur(15px);
            position: relative;
            overflow: hidden;
            box-shadow: 0 5px 25px rgba(0, 180, 255, 0.1);
        }

        .song-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(0, 255, 170, 0.15), 
                rgba(0, 180, 255, 0.15), 
                transparent
            );
            transition: left 0.6s ease;
        }

        .song-card:hover::before {
            left: 100%;
        }

        .song-card:hover {
            border-color: #00FFAA;
            box-shadow: 
                0 15px 40px rgba(0, 255, 170, 0.3),
                0 0 30px rgba(0, 180, 255, 0.2);
            transform: translateY(-8px) scale(1.02);
            background: rgba(0, 80, 120, 0.25);
        }

        .song-title {
            font-family: 'Orbitron', monospace;
            font-size: 1.3rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            text-align: center;
        }

        .song-artist {
            font-size: 0.9rem;
            color: #a0a0ff;
            text-align: center;
            opacity: 0.8;
        }

        .custom-card {
            grid-column: 1 / -1;
            background: linear-gradient(45deg, rgba(255, 0, 220, 0.1), rgba(0, 212, 255, 0.1));
            border-color: #ff00dc;
        }

        .custom-card:hover {
            border-color: #ff00dc;
            box-shadow: 0 10px 30px rgba(255, 0, 220, 0.3);
        }

        .settings-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            color: white;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .settings-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: #00d4ff;
        }

        .settings-btn.calibrated::after {
            content: '✓';
            position: absolute;
            bottom: -5px;
            right: -5px;
            background: #4CAF50;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid #0f0f23;
        }

        .difficulty-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .easy { background: #4CAF50; }
        .normal { background: #2196F3; }
        .hard { background: #FF9800; }
        .expert { background: #F44336; }

        /* Calibration Modal Styles */
        .calibration-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .calibration-overlay.active {
            display: flex;
        }

        .calibration-modal {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 2rem;
            max-width: 600px;
            width: 90%;
            text-align: center;
            backdrop-filter: blur(20px);
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.8);
        }

        .calibration-title {
            font-family: 'Orbitron', monospace;
            font-size: 2rem;
            font-weight: 700;
            background: linear-gradient(45deg, #00d4ff, #ff00dc);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 1rem;
        }

        .calibration-description {
            color: #a0a0ff;
            font-size: 1.1rem;
            margin-bottom: 2rem;
            line-height: 1.6;
        }

        .metronome-container {
            position: relative;
            width: 200px;
            height: 200px;
            margin: 2rem auto;
            border: 3px solid #00d4ff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 212, 255, 0.1);
        }

        .metronome-beat {
            width: 60px;
            height: 60px;
            background: #00d4ff;
            border-radius: 50%;
            transition: all 0.1s ease;
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
        }

        .metronome-beat.active {
            background: #ff00dc;
            box-shadow: 0 0 30px rgba(255, 0, 220, 0.8);
            transform: scale(1.2);
        }

        .calibration-instructions {
            color: #ffffff;
            font-size: 1.2rem;
            margin: 1.5rem 0;
            font-weight: 600;
        }

        .calibration-key {
            display: inline-block;
            padding: 0.8rem 1.5rem;
            background: linear-gradient(45deg, #00d4ff, #0099cc);
            color: white;
            border-radius: 10px;
            font-family: 'Orbitron', monospace;
            font-size: 1.5rem;
            font-weight: 700;
            margin: 0 0.5rem;
            box-shadow: 0 5px 15px rgba(0, 212, 255, 0.3);
        }

        .calibration-stats {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 1rem;
            margin: 1.5rem 0;
            display: none;
        }

        .calibration-stats.active {
            display: block;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 0.5rem 0;
            color: #a0a0ff;
        }

        .stat-value {
            color: #00d4ff;
            font-weight: 700;
        }

        .calibration-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 2rem;
        }

        .calibration-progress {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            margin: 1rem 0;
            overflow: hidden;
        }

        .calibration-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff, #00ff88);
            width: 0%;
            transition: width 0.3s ease;
        }

        .btn {
            padding: 0.8rem 1.5rem;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Orbitron', monospace;
            font-size: 0.9rem;
            text-decoration: none;
            display: inline-block;
            font-weight: 600;
        }

        .btn:hover {
            border-color: #00d4ff;
            background: rgba(0, 212, 255, 0.2);
            box-shadow: 0 5px 15px rgba(0, 212, 255, 0.3);
        }

        .btn.primary {
            background: linear-gradient(45deg, #00d4ff, #0099cc);
            border-color: #00d4ff;
            color: white;
        }

        .btn.primary:hover {
            background: linear-gradient(45deg, #00b8e6, #007399);
            box-shadow: 0 8px 20px rgba(0, 212, 255, 0.4);
        }

        @media (max-width: 768px) {
            .title { font-size: 2.5rem; }
            .menu-grid { grid-template-columns: 1fr; }
            .song-card { padding: 1rem; }
            .calibration-modal { padding: 1.5rem; }
            .calibration-title { font-size: 1.5rem; }
            .metronome-container { width: 150px; height: 150px; }
        }
    </style>
</head>
<body>
    <div class="background-animation" id="particles"></div>
    
    <!-- Audio Offset Calibration Modal -->
    <div id="calibration-overlay" class="calibration-overlay">
        <div class="calibration-modal">
            <h2 class="calibration-title">Audio Offset Calibration</h2>
            <p class="calibration-description">
                Let's calibrate your audio offset for the best rhythm game experience!<br>
                This will help synchronize the audio with your input for perfect timing.
            </p>
            
            <div class="metronome-container">
                <div id="metronome-beat" class="metronome-beat"></div>
            </div>
            
            <div class="calibration-instructions">
                Press <span class="calibration-key">D</span> in sync with the beat
            </div>
            
            <div class="calibration-progress">
                <div id="calibration-progress-fill" class="calibration-progress-fill"></div>
            </div>
            
            <div id="calibration-stats" class="calibration-stats">
                <div class="stat-row">
                    <span>Taps Recorded:</span>
                    <span id="taps-count" class="stat-value">0</span>
                </div>
                <div class="stat-row">
                    <span>Average Offset:</span>
                    <span id="avg-offset" class="stat-value">0 ms</span>
                </div>
                <div class="stat-row">
                    <span>Consistency:</span>
                    <span id="consistency" class="stat-value">-</span>
                </div>
            </div>
            
            <div class="calibration-buttons">
                <button id="start-calibration" class="btn primary">Start Calibration</button>
                <button id="finish-calibration" class="btn" style="display: none;">Save & Continue</button>
                <button id="skip-calibration" class="btn">Skip for Now</button>
            </div>
        </div>
    </div>
    
    <div class="container">
        <button class="settings-btn" onclick="openSettings()">⚙️</button>
        
        <h1 class="title">WAVE RHYTHM</h1>
        <p class="subtitle">Enhanced 4-Key Rhythm Experience</p>
        
        <div class="menu-grid">
            <a href="game.html?song=naruto" class="song-card">
                <div class="difficulty-badge expert">EXPERT</div>
                <div class="song-title">Naruto - Silhouette</div>
                <div class="song-artist">KANA-BOOM</div>
            </a>
            
            <a href="game.html?song=nano-death" class="song-card">
                <div class="difficulty-badge expert">EXPERT</div>
                <div class="song-title">NANO DEATH!!!!!</div>
                <div class="song-artist">LeaF</div>
            </a>
            
            <a href="game.html?song=elysium" class="song-card">
                <div class="difficulty-badge hard">HARD</div>
                <div class="song-title">Elysium</div>
                <div class="song-artist">Rob Gasser</div>
            </a>
            
            <a href="game.html?song=yeah-boy" class="song-card">
                <div class="difficulty-badge expert">EXPERT</div>
                <div class="song-title">Yeah Boy</div>
                <div class="song-artist">Shooting Stars</div>
            </a>
            
            <a href="game.html?song=zenith-another" class="song-card">
                <div class="difficulty-badge expert">EXPERT++</div>
                <div class="song-title">Blue Zenith</div>
                <div class="song-artist">xi - Frenzy Another</div>
            </a>
            
            <a href="game.html?song=zenith" class="song-card">
                <div class="difficulty-badge expert">EXPERT+</div>
                <div class="song-title">Blue Zenith</div>
                <div class="song-artist">xi - Four Dimensions</div>
            </a>
            
            <a href="game.html" class="song-card custom-card">
                <div class="song-title">Custom Chart</div>
                <div class="song-artist">Load your own beatmaps</div>
            </a>
        </div>
    </div>

    <script src="js/SettingsManager.js"></script>
    <script>
        // Audio Offset Calibration System
        class AudioCalibration {
            constructor() {
                this.isActive = false;
                this.audioContext = null;
                this.metronomeGain = null;
                this.metronomeOscillator = null;
                this.bpm = 120;
                this.beatInterval = 60000 / this.bpm; // ms per beat
                this.startTime = 0;
                this.beatCount = 0;
                this.tapTimes = [];
                this.beatTimes = [];
                this.minTaps = 8;
                this.maxTaps = 20;
                this.targetTaps = 12;
                
                this.initializeElements();
                this.bindEvents();
            }
            
            initializeElements() {
                this.overlay = document.getElementById('calibration-overlay');
                this.metronomeBeat = document.getElementById('metronome-beat');
                this.progressFill = document.getElementById('calibration-progress-fill');
                this.statsContainer = document.getElementById('calibration-stats');
                this.tapsCountElement = document.getElementById('taps-count');
                this.avgOffsetElement = document.getElementById('avg-offset');
                this.consistencyElement = document.getElementById('consistency');
                this.startButton = document.getElementById('start-calibration');
                this.finishButton = document.getElementById('finish-calibration');
                this.skipButton = document.getElementById('skip-calibration');
            }
            
            bindEvents() {
                this.startButton.addEventListener('click', () => this.startCalibration());
                this.finishButton.addEventListener('click', () => this.finishCalibration());
                this.skipButton.addEventListener('click', () => this.skipCalibration());
                
                document.addEventListener('keydown', (e) => {
                    if (this.isActive && e.keyCode === 68) { // D key
                        e.preventDefault();
                        this.recordTap();
                    }
                });
            }
            
            async initAudioContext() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.metronomeGain = this.audioContext.createGain();
                    this.metronomeGain.connect(this.audioContext.destination);
                    this.metronomeGain.gain.value = 0.3;
                    return true;
                } catch (error) {
                    console.error('Failed to initialize audio context:', error);
                    return false;
                }
            }
            
            playMetronomeSound() {
                if (!this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                
                oscillator.connect(gain);
                gain.connect(this.metronomeGain);
                
                oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
                gain.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.1);
            }
            
            async startCalibration() {
                const audioReady = await this.initAudioContext();
                if (!audioReady) {
                    alert('Unable to initialize audio. Please check your browser permissions.');
                    return;
                }
                
                this.isActive = true;
                this.startTime = performance.now();
                this.beatCount = 0;
                this.tapTimes = [];
                this.beatTimes = [];
                
                this.startButton.style.display = 'none';
                this.statsContainer.classList.add('active');
                
                this.runMetronome();
            }
            
            runMetronome() {
                const now = performance.now();
                const expectedBeatTime = this.startTime + (this.beatCount * this.beatInterval);
                
                if (now >= expectedBeatTime) {
                    this.playBeat();
                    this.beatTimes.push(now);
                    this.beatCount++;
                    
                    // Stop after enough beats for calibration
                    if (this.beatCount >= this.maxTaps + 5) {
                        this.stopCalibration();
                        return;
                    }
                }
                
                if (this.isActive) {
                    requestAnimationFrame(() => this.runMetronome());
                }
            }
            
            playBeat() {
                this.playMetronomeSound();
                this.metronomeBeat.classList.add('active');
                setTimeout(() => {
                    this.metronomeBeat.classList.remove('active');
                }, 100);
            }
            
            recordTap() {
                if (!this.isActive || this.beatCount < 2) return; // Ignore early taps
                
                const tapTime = performance.now();
                this.tapTimes.push(tapTime);
                
                this.updateStats();
                this.updateProgress();
                
                if (this.tapTimes.length >= this.targetTaps) {
                    this.finishButton.style.display = 'inline-block';
                }
            }
            
            updateStats() {
                this.tapsCountElement.textContent = this.tapTimes.length;
                
                if (this.tapTimes.length >= 3) {
                    const offset = this.calculateOffset();
                    this.avgOffsetElement.textContent = `${Math.round(offset)} ms`;
                    
                    const consistency = this.calculateConsistency();
                    this.consistencyElement.textContent = consistency;
                }
            }
            
            updateProgress() {
                const progress = Math.min((this.tapTimes.length / this.targetTaps) * 100, 100);
                this.progressFill.style.width = `${progress}%`;
            }
            
            calculateOffset() {
                if (this.tapTimes.length < 3) return 0;
                
                let totalOffset = 0;
                let validTaps = 0;
                
                for (let i = 0; i < this.tapTimes.length; i++) {
                    const tapTime = this.tapTimes[i];
                    
                    // Find the closest beat
                    let closestBeatTime = null;
                    let minDistance = Infinity;
                    
                    for (const beatTime of this.beatTimes) {
                        const distance = Math.abs(tapTime - beatTime);
                        if (distance < minDistance && distance < this.beatInterval / 2) {
                            minDistance = distance;
                            closestBeatTime = beatTime;
                        }
                    }
                    
                    if (closestBeatTime !== null) {
                        totalOffset += (tapTime - closestBeatTime);
                        validTaps++;
                    }
                }
                
                return validTaps > 0 ? totalOffset / validTaps : 0;
            }
            
            calculateConsistency() {
                if (this.tapTimes.length < 4) return 'Calculating...';
                
                const offsets = [];
                
                for (let i = 0; i < this.tapTimes.length; i++) {
                    const tapTime = this.tapTimes[i];
                    
                    let closestBeatTime = null;
                    let minDistance = Infinity;
                    
                    for (const beatTime of this.beatTimes) {
                        const distance = Math.abs(tapTime - beatTime);
                        if (distance < minDistance && distance < this.beatInterval / 2) {
                            minDistance = distance;
                            closestBeatTime = beatTime;
                        }
                    }
                    
                    if (closestBeatTime !== null) {
                        offsets.push(Math.abs(tapTime - closestBeatTime));
                    }
                }
                
                if (offsets.length < 3) return 'Need more taps';
                
                const avgDeviation = offsets.reduce((a, b) => a + b, 0) / offsets.length;
                
                if (avgDeviation < 20) return 'Excellent';
                if (avgDeviation < 40) return 'Good';
                if (avgDeviation < 60) return 'Fair';
                return 'Needs Practice';
            }
            
            stopCalibration() {
                this.isActive = false;
                if (this.tapTimes.length >= this.minTaps) {
                    this.finishButton.style.display = 'inline-block';
                }
            }
            
            finishCalibration() {
                const calculatedOffset = this.calculateOffset();
                
                // Save calibration to settings
                const savedOffset = gameSettings.saveCalibration(calculatedOffset);
                
                this.hideCalibration();
                updateSettingsButtonStatus();
                
                // Show confirmation
                this.showCalibrationResult(savedOffset);
            }
            
            skipCalibration() {
                gameSettings.set('isCalibrated', true); // Mark as calibrated (skipped)
                gameSettings.saveSettings();
                this.hideCalibration();
                updateSettingsButtonStatus();
                
                // Show info about manual calibration
                setTimeout(() => {
                    alert('Calibration skipped.\n\nYou can calibrate your audio offset later by clicking the settings button (⚙️) in the top-right corner.\n\nProper calibration helps ensure the best rhythm game experience!');
                }, 100);
            }
            
            hideCalibration() {
                this.overlay.classList.remove('active');
                this.isActive = false;
                
                if (this.audioContext) {
                    this.audioContext.close();
                    this.audioContext = null;
                }
            }
            
            showCalibrationResult(offset) {
                const message = `Calibration complete!\n\nYour audio offset has been set to ${Math.round(offset)}ms.\n\nThis will be used for all songs to ensure perfect timing synchronization.\n\nYou can recalibrate anytime by clicking the settings button (⚙️) in the top-right corner.`;
                
                setTimeout(() => {
                    alert(message);
                }, 100);
            }
            
            show() {
                this.overlay.classList.add('active');
            }
        }
        
        // Initialize calibration system
        const audioCalibration = new AudioCalibration();
        
        // Create floating particles
        function createParticles() {
            const container = document.getElementById('particles');
            const particleCount = 50;

            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 8 + 's';
                particle.style.animationDuration = (Math.random() * 4 + 6) + 's';
                container.appendChild(particle);
            }
        }

        function openSettings() {
            // Create a more detailed settings modal
            const currentOffset = gameSettings.get('audioOffset');
            const isCalibrated = gameSettings.get('isCalibrated');
            const lastCalibration = gameSettings.get('lastCalibrationDate');
            
            let calibrationInfo = '';
            if (isCalibrated) {
                const date = lastCalibration ? new Date(lastCalibration).toLocaleDateString() : 'Unknown';
                calibrationInfo = `\nCurrent audio offset: ${currentOffset}ms\nLast calibrated: ${date}`;
            } else {
                calibrationInfo = '\nAudio offset: Not calibrated';
            }
            
            const choice = confirm(`Settings:\n• Key bindings: D-F-J-K\n• Audio offset: ${currentOffset}ms\n• Visual effects: Enabled\n• Scroll speed: ${gameSettings.get('scrollSpeed')}\n• Scale: ${gameSettings.get('scale')}%${calibrationInfo}\n\nWould you like to recalibrate your audio offset?`);
            
            if (choice) {
                audioCalibration.show();
            }
        }
        
        // Check if user needs calibration on page load
        function checkCalibrationNeeded() {
            console.log('Checking calibration need...');
            try {
                // Check if user needs calibration
                const needsCalibration = gameSettings.isCalibrationNeeded();
                console.log('Needs calibration:', needsCalibration);
                
                if (needsCalibration) {
                    console.log('Showing calibration modal in 1 second...');
                    // Show calibration after a short delay to let page load
                    setTimeout(() => {
                        audioCalibration.show();
                        console.log('Calibration modal should be visible now');
                    }, 1000);
                } else {
                    console.log('User already calibrated, skipping calibration modal');
                }
            } catch (error) {
                console.error('Error checking calibration:', error);
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, initializing...');
            console.log('gameSettings available:', typeof gameSettings !== 'undefined');
            
            createParticles();
            checkCalibrationNeeded();
            updateSettingsButtonStatus();
            
            console.log('Initialization complete');
        });
        
        // Update settings button to show calibration status
        function updateSettingsButtonStatus() {
            const settingsBtn = document.querySelector('.settings-btn');
            const isCalibrated = gameSettings.get('isCalibrated');
            
            if (isCalibrated) {
                settingsBtn.classList.add('calibrated');
                settingsBtn.title = 'Settings (Audio calibrated ✓)';
            } else {
                settingsBtn.classList.remove('calibrated');
                settingsBtn.title = 'Settings (Audio not calibrated)';
            }
        }
    </script>
</body>
</html>