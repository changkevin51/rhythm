<!doctype html>
<html lang="en">
<head>
    <title>Tidal Beats - Game</title>
    <meta charset="UTF-8">
    <meta name="description" content="Rhythm game">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Exo+2:wght@300;400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="game.css">
</head>
<body>
    <div class="game-header">
        <div class="song-info">
            <h1 id="song-title">Loading...</h1>
            <p><span id="song-artist"></span><span id="song-difficulty" class="difficulty-badge"></span></p>
        </div>
        <div class="header-controls">
            <a class="btn" href="index.html">Change Song</a>
        </div>
    </div>

    <div class="main-content">
        <div id="loading-screen" class="loading-screen active">
            <p>Loading song...</p>
        </div>

        <div id="game-setup" class="game-setup">
            <h2 id="setup-title">Game Settings</h2>
            
            <div id="custom-upload-section" style="display:none;">
                <div class="upload-mode-selector">
                    <button class="mode-btn active" onclick="switchUploadMode('individual')">Individual Files</button>
                    <button class="mode-btn" onclick="switchUploadMode('osz')">OSZ Archive</button>
                </div>
                
                <div id="individual-upload" class="upload-section active">
                    <div class="form-group">
                        <label for="uploadOsu">Chart File (.osu / .txt):</label>
                        <input type="file" id="uploadOsu" class="custom-file-input" accept=".osu,.txt">
                        <label for="uploadOsu" class="file-input-label">Choose Chart File</label>
                        <div id="chart-status" class="file-status" style="display:none;"></div>
                    </div>
                    <div class="form-group">
                        <label for="uploadAudio">Audio File (.mp3, .ogg, .wav):</label>
                        <input type="file" id="uploadAudio" class="custom-file-input" accept=".mp3,.wav,.ogg">
                        <label for="uploadAudio" class="file-input-label">Choose Audio File</label>
                        <div id="audio-status" class="file-status" style="display:none;"></div>
                    </div>
                </div>
                
                <div id="osz-upload" class="upload-section">
                    <div class="form-group">
                        <label for="uploadOsz">OSZ Archive (.osz):</label>
                        <input type="file" id="uploadOsz" class="custom-file-input" accept=".osz">
                        <label for="uploadOsz" class="file-input-label">Choose OSZ File</label>
                        <div id="osz-status" class="file-status" style="display:none;"></div>
                    </div>
                    <div id="chart-selection" style="display:none;">
                        <label for="chartSelect">Select Chart:</label>
                        <select id="chartSelect" style="width: 100%; padding: 10px; margin-top: 5px; background: rgba(255, 255, 255, 0.1); color: white; border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 8px;">
                        </select>
                    </div>
                </div>
            </div>

            <div class="form-group">
                <label for="inputScale">Display Scale (%):</label>
                <input type="number" id="inputScale" value="100" min="50" max="150" step="10">
            </div>
            <div class="form-group">
                <label for="scrollDurationInput">Scroll Speed:</label>
                <input type="number" id="scrollDurationInput" value="500" min="200" max="1000" step="50">
            </div>
            <div class="form-group">
                <label for="inputOffset">Audio Offset (ms):</label>
                <input type="number" id="inputOffset" value="-50" min="-200" max="200" step="10">
            </div>
            <div class="form-group">
                <label for="baseBPM">Base BPM (optional):</label>
                <input type="number" id="baseBPM" placeholder="Auto-detect">
            </div>
            <button class="btn" id="start-game-btn">Start Game</button>
        </div>

        <div id="game-container" class="game-container">
            <canvas id="myCanvas" width="600" height="800"></canvas>
        </div>
    </div>

    <audio id="audioPlayer" preload="auto"></audio>

    <!-- JSZip library for handling .osz files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="js/SettingsManager.js"></script>
    <script src="js/SongManager.js"></script>
    <script src="js/WaveAnimationManager.js"></script>
    <script src="js/Game_Pre.js"></script>

    <script>
        let chartDataFromLoader = null;
        let filesLoaded = { chart: false, audio: false };
        let currentUploadMode = 'individual';
        let oszData = null;
        let availableCharts = [];

        // Fallback validation functions if GameUtils is not available
        const BeatmapUtils = {
            isValidChartFile(file) {
                const validExtensions = ['.osu', '.txt'];
                const fileName = file.name.toLowerCase();
                return validExtensions.some(ext => fileName.endsWith(ext));
            },

            isValidAudioFile(file) {
                const validExtensions = ['.mp3', '.wav', '.ogg'];
                const fileName = file.name.toLowerCase();
                return validExtensions.some(ext => fileName.endsWith(ext));
            },

            isValidArchive(file) {
                const fileName = file.name.toLowerCase();
                return fileName.endsWith('.osz') || fileName.endsWith('.zip');
            },

            async readChartFile(file) {
                return new Promise((resolve, reject) => {
                    if (!this.isValidChartFile(file)) {
                        reject(new Error('Invalid chart file format. Please use .osu or .txt files.'));
                        return;
                    }

                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const content = event.target.result;
                            
                            // Basic validation for .osu files
                            if (file.name.toLowerCase().endsWith('.osu')) {
                                const validationResult = this.validateOsuFile(content);
                                if (!validationResult.isValid) {
                                    reject(new Error(validationResult.error));
                                    return;
                                }
                            }
                            
                            resolve(content);
                        } catch (error) {
                            reject(new Error('Failed to read chart file: ' + error.message));
                        }
                    };
                    reader.onerror = () => {
                        reject(new Error('Failed to read chart file'));
                    };
                    reader.readAsText(file, 'UTF-8');
                });
            },

            validateOsuFile(content) {
                try {
                    const lines = content.split('\n').map(line => line.trim());
                    let inGeneralSection = false;
                    let modeFound = false;
                    let mode = null;

                    for (const line of lines) {
                        if (line.startsWith('[') && line.endsWith(']')) {
                            inGeneralSection = line.toLowerCase() === '[general]';
                            continue;
                        }

                        if (inGeneralSection && line.toLowerCase().startsWith('mode:')) {
                            modeFound = true;
                            mode = parseInt(line.split(':')[1].trim());
                            break;
                        }
                    }

                    if (!modeFound) {
                        return {
                            isValid: false,
                            error: 'Invalid osu! file: Mode not specified. Please ensure this is a valid osu!mania beatmap (Mode: 3).'
                        };
                    }

                    if (mode !== 3) {
                        const modeNames = {
                            0: 'osu! (Standard)',
                            1: 'Taiko',
                            2: 'Catch the Beat',
                            3: 'osu!mania'
                        };
                        
                        return {
                            isValid: false,
                            error: `Invalid game mode: This beatmap is for ${modeNames[mode] || 'Unknown mode'} (Mode: ${mode}). Please use an osu!mania beatmap (Mode: 3).`
                        };
                    }

                    return { isValid: true, mode: mode };

                } catch (error) {
                    return {
                        isValid: false,
                        error: 'Failed to parse osu! file: ' + error.message
                    };
                }
            },

            async readAudioFile(file) {
                return new Promise((resolve, reject) => {
                    if (!this.isValidAudioFile(file)) {
                        reject(new Error('Invalid audio file format. Please use .mp3, .wav, or .ogg files.'));
                        return;
                    }

                    try {
                        const audioURL = URL.createObjectURL(file);
                        resolve({
                            url: audioURL,
                            filename: file.name,
                            size: file.size,
                            type: file.type
                        });
                    } catch (error) {
                        reject(new Error('Failed to process audio file: ' + error.message));
                    }
                });
            },

            async setupAudioElement(audioElement, audioData) {
                return new Promise((resolve, reject) => {
                    if (!audioData || !audioData.url) {
                        reject(new Error('Invalid audio data'));
                        return;
                    }

                    const audio = audioElement;
                    
                    // Clear any existing source
                    audio.src = '';
                    audio.load();

                    // Set up event listeners
                    const onCanPlay = () => {
                        audio.removeEventListener('canplay', onCanPlay);
                        audio.removeEventListener('error', onError);
                        resolve(audio);
                    };

                    const onError = (e) => {
                        audio.removeEventListener('canplay', onCanPlay);
                        audio.removeEventListener('error', onError);
                        reject(new Error('Failed to load audio: ' + (e.message || 'Unknown error')));
                    };

                    audio.addEventListener('canplay', onCanPlay);
                    audio.addEventListener('error', onError);

                    // Set the source and load
                    audio.src = audioData.url;
                    audio.load();
                });
            },

            async extractOszArchive(file) {
                return new Promise((resolve, reject) => {
                    if (!this.isValidArchive(file)) {
                        reject(new Error('Invalid archive format. Please use .osz or .zip files.'));
                        return;
                    }

                    // Check if JSZip is available
                    if (typeof JSZip === 'undefined') {
                        reject(new Error('JSZip library is required for .osz support. Please reload the page.'));
                        return;
                    }

                    const reader = new FileReader();
                    reader.onload = async (event) => {
                        try {
                            const zip = new JSZip();
                            const zipData = await zip.loadAsync(event.target.result);
                            
                            const extractedFiles = {
                                charts: [],
                                audio: [],
                                images: [],
                                other: []
                            };

                            // Process each file in the archive
                            for (const [filename, fileData] of Object.entries(zipData.files)) {
                                if (fileData.dir) continue; // Skip directories

                                const lowerName = filename.toLowerCase();
                                
                                if (lowerName.endsWith('.osu')) {
                                    const content = await fileData.async('text');
                                    
                                    // Validate osu!mania mode for charts in archive
                                    const validationResult = this.validateOsuFile(content);
                                    if (validationResult.isValid) {
                                        extractedFiles.charts.push({
                                            filename,
                                            content,
                                            size: content.length,
                                            mode: validationResult.mode
                                        });
                                    } else {
                                        console.warn(`Skipping ${filename}: ${validationResult.error}`);
                                    }
                                } else if (lowerName.endsWith('.mp3') || lowerName.endsWith('.wav') || lowerName.endsWith('.ogg')) {
                                    const blob = await fileData.async('blob');
                                    extractedFiles.audio.push({
                                        filename,
                                        url: URL.createObjectURL(blob),
                                        size: blob.size,
                                        type: blob.type
                                    });
                                } else if (lowerName.endsWith('.jpg') || lowerName.endsWith('.jpeg') || lowerName.endsWith('.png')) {
                                    const blob = await fileData.async('blob');
                                    extractedFiles.images.push({
                                        filename,
                                        url: URL.createObjectURL(blob),
                                        size: blob.size
                                    });
                                }
                            }

                            resolve(extractedFiles);
                        } catch (error) {
                            reject(new Error('Failed to extract archive: ' + error.message));
                        }
                    };
                    reader.onerror = () => {
                        reject(new Error('Failed to read archive file'));
                    };
                    reader.readAsArrayBuffer(file);
                });
            },

            parseChartMetadata(content) {
                const metadata = {
                    title: 'Unknown Title',
                    artist: 'Unknown Artist',
                    creator: 'Unknown Creator',
                    version: 'Unknown Difficulty'
                };

                const lines = content.split('\n');
                let inMetadataSection = false;

                for (const line of lines) {
                    const trimmedLine = line.trim();
                    
                    if (trimmedLine.startsWith('[') && trimmedLine.endsWith(']')) {
                        inMetadataSection = trimmedLine.toLowerCase() === '[metadata]';
                        continue;
                    }

                    if (inMetadataSection && trimmedLine.includes(':')) {
                        const [key, value] = trimmedLine.split(':', 2);
                        const cleanKey = key.trim().toLowerCase();
                        const cleanValue = value.trim();

                        switch (cleanKey) {
                            case 'title':
                                metadata.title = cleanValue;
                                break;
                            case 'artist':
                                metadata.artist = cleanValue;
                                break;
                            case 'creator':
                                metadata.creator = cleanValue;
                                break;
                            case 'version':
                                metadata.version = cleanValue;
                                break;
                        }
                    }
                }

                return metadata;
            }
        };

        // Use GameUtils if available, otherwise use fallback
        const beatmapAPI = (typeof GameUtils !== 'undefined' && GameUtils.beatmap) ? GameUtils.beatmap : BeatmapUtils;
        
        // Make beatmapAPI globally available for SongManager
        window.beatmapAPI = beatmapAPI;

        // Upload mode switching
        function switchUploadMode(mode) {
            currentUploadMode = mode;
            
            // Update button states
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // Show/hide sections
            document.querySelectorAll('.upload-section').forEach(section => section.classList.remove('active'));
            document.getElementById(mode === 'individual' ? 'individual-upload' : 'osz-upload').classList.add('active');
            
            // Reset states
            resetUploadStates();
        }

        function resetUploadStates() {
            filesLoaded = { chart: false, audio: false };
            chartDataFromLoader = null;
            oszData = null;
            availableCharts = [];
            document.getElementById('start-game-btn').disabled = true;
            
            // Hide all status messages
            document.querySelectorAll('.file-status').forEach(status => {
                status.style.display = 'none';
            });
            
            // Reset file inputs
            document.querySelectorAll('input[type="file"]').forEach(input => {
                input.value = '';
            });
        }

        function showStatus(elementId, message, isError = false) {
            const statusDiv = document.getElementById(elementId);
            statusDiv.textContent = message;
            statusDiv.className = `file-status ${isError ? 'error' : 'success'}`;
            statusDiv.style.display = 'block';
        }

        // This function is the main entry point after files are ready.
        function showGameSetup(chartText, songTitle) {
            chartDataFromLoader = chartText;

            // Show setup screen
            document.getElementById('loading-screen').classList.remove('active');
            const setupScreen = document.getElementById('game-setup');
            setupScreen.classList.add('active');
            document.getElementById('setup-title').textContent = songTitle || "Custom Song";

            // If chartText is null, it means we are in custom upload mode.
            if (!chartText) {
                document.getElementById('custom-upload-section').style.display = 'block';
                document.getElementById('start-game-btn').disabled = true;
            } else {
                 document.getElementById('custom-upload-section').style.display = 'none';
                 document.getElementById('start-game-btn').disabled = false;
            }
        }

        // The button click handler for starting the game
        document.getElementById('start-game-btn').addEventListener('click', async () => {
            if (!chartDataFromLoader && !filesLoaded.chart) {
                alert("Chart data not loaded! Please select a song or upload a file.");
                return;
            }

            console.log('Start game button clicked, preparing to start...');
            
            // Disable the start button to prevent multiple clicks
            const startBtn = document.getElementById('start-game-btn');
            startBtn.disabled = true;
            startBtn.textContent = 'Starting...';
            
            try {
                // Initialize wave manager if available and wait for it to be ready
                if (typeof waveManager !== 'undefined' && waveManager.loadPromise) {
                    console.log('Waiting for existing wave manager to be ready...');
                    await waveManager.loadPromise; // Wait for wave frames to load
                    console.log('Wave manager ready');
                } else if (typeof WaveAnimationManager !== 'undefined') {
                    console.log('Creating wave manager...');
                    window.waveManager = new WaveAnimationManager();
                    await waveManager.loadPromise; // Wait for wave frames to load
                    console.log('Wave manager ready');
                }
                
                // Small delay to ensure DOM is fully ready
                await new Promise(resolve => setTimeout(resolve, 100));
                
                console.log('Starting game now...');
                startGameNow();
                
            } catch (error) {
                console.error('Error during game initialization:', error);
                alert('Error starting game: ' + error.message);
                
                // Re-enable the button
                startBtn.disabled = false;
                startBtn.textContent = 'Start Game';
            }
        });
        
        function startGameNow() {
            console.log('Starting game now...');
            
            // Debug: Check critical elements
            const audioElement = document.getElementById('audioPlayer');
            const canvasElement = document.getElementById('myCanvas');
            console.log('Audio element exists:', !!audioElement);
            console.log('Canvas element exists:', !!canvasElement);
            console.log('Chart data exists:', !!chartDataFromLoader);
            console.log('Chart data length:', chartDataFromLoader ? chartDataFromLoader.length : 0);
            
            if (!chartDataFromLoader) {
                console.error('No chart data available!');
                alert('No chart data loaded. Please select a song first.');
                return;
            }
            
            if (!audioElement) {
                console.error('Audio element not found!');
                alert('Audio player not found. There may be an issue with the HTML.');
                return;
            }
            
            if (!canvasElement) {
                console.error('Canvas element not found!');
                alert('Game canvas not found. There may be an issue with the HTML.');
                return;
            }
            
            try {
                // 0. First initialize game elements
                if (!initializeGameElements()) {
                    throw new Error('Failed to initialize game elements (canvas, audio, etc.)');
                }
                
                // 0.5. Reset game state to ensure clean start
                resetGameState();
                
                // 1. Process the chart data using the original working function
                processChartData(chartDataFromLoader);

                // 2. Apply settings from the form if they exist
                if (document.getElementById('inputScale')) {
                    Scale = Number(document.getElementById('inputScale').value) || 100;
                }
                if (document.getElementById("scrollDurationInput")) {
                    scrollDuration = Number(document.getElementById("scrollDurationInput").value) || 500;
                }
                if (document.getElementById("inputOffset")) {
                    offset = Number(document.getElementById("inputOffset").value) || -40;
                }
                updateOffsetFromSettings(); // Update effective offset
                
                // --- THIS IS THE FIX ---
                // Get the baseMpB from the first timing point.
                const baseBPMElement = document.getElementById("baseBPM");
                if (baseBPMElement && baseBPMElement.value) {
                    // If user provides a value, use it (convert BPM to ms per beat)
                    baseMpB = 60000 / Number(baseBPMElement.value);
                    console.log(`User-provided baseMpB: ${baseMpB} (from ${baseBPMElement.value} BPM)`);
                } else {
                    // Get it automatically from the first uninherited timing point.
                    const chartBaseMpB = getBaseMpBFromChart();
                    if (chartBaseMpB && chartBaseMpB > 0) {
                        baseMpB = chartBaseMpB;
                        console.log(`Auto-detected baseMpB: ${baseMpB}`);
                    } else {
                        // As a last resort, use a sane default (e.g., 120 BPM)
                        baseMpB = 60000 / 120; // 500ms per beat for 120 BPM
                        console.warn(`Could not detect baseMpB, falling back to default: ${baseMpB}`);
                    }
                }
                // --- END OF FIX ---

                // 3. Hide setup, show game
                document.getElementById('game-setup').classList.remove('active');
                document.getElementById('game-container').classList.add('active');

                // 4. Initialize key listeners and start the game
                initKeyListener();
                updateOffsetFromSettings(); // Ensure offset is updated one more time
                
                console.log('Starting game with chartDataFromLoader:', !!chartDataFromLoader);
                
                // Add a timeout to detect if the game gets stuck
                const gameStartTimeout = setTimeout(() => {
                    console.error('Game start timeout - game may be stuck');
                    alert('Game appears to be stuck during startup. Please refresh and try again.');
                }, 10000); // 10 second timeout
                
                try {
                    startTime();
                    console.log('Game started successfully');
                    clearTimeout(gameStartTimeout);
                } catch (error) {
                    console.error('Error in startTime():', error);
                    clearTimeout(gameStartTimeout);
                    throw error;
                }
            } catch (error) {
                console.error('Error starting game:', error);
                alert('Error starting game: ' + error.message);
            }
        }

        // --- Individual File Upload Logic ---
        document.getElementById('uploadOsu').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            try {
                // Validate file type
                if (!beatmapAPI.isValidChartFile(file)) {
                    throw new Error('Invalid chart file format. Please select a .osu or .txt file.');
                }

                const chartData = await beatmapAPI.readChartFile(file);
                
                chartDataFromLoader = chartData;
                filesLoaded.chart = true;
                showStatus('chart-status', `Loaded: ${file.name}`);
                
                if (filesLoaded.audio) {
                    document.getElementById('start-game-btn').disabled = false;
                }
            } catch (error) {
                showStatus('chart-status', `Error: ${error.message}`, true);
                filesLoaded.chart = false;
                chartDataFromLoader = null;
            }
        });

        document.getElementById('uploadAudio').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            try {
                // Validate file type
                if (!beatmapAPI.isValidAudioFile(file)) {
                    throw new Error('Invalid audio file format. Please select a .mp3, .wav, or .ogg file.');
                }

                const audioElement = document.getElementById('audioPlayer');
                const audioData = await beatmapAPI.readAudioFile(file);
                await beatmapAPI.setupAudioElement(audioElement, audioData);
                
                filesLoaded.audio = true;
                showStatus('audio-status', `Loaded: ${file.name}`);
                
                if (filesLoaded.chart) {
                    document.getElementById('start-game-btn').disabled = false;
                }
            } catch (error) {
                showStatus('audio-status', `Error: ${error.message}`, true);
                filesLoaded.audio = false;
            }
        });

        // --- OSZ File Upload Logic ---
        document.getElementById('uploadOsz').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            try {
                // Validate file type
                if (!beatmapAPI.isValidArchive(file)) {
                    throw new Error('Invalid archive file. Please select a .osz file.');
                }

                showStatus('osz-status', 'Extracting archive...');
                
                // Extract OSZ archive
                const extractedData = await beatmapAPI.extractOszArchive(file);
                oszData = extractedData;
                
                // Check if we have charts and audio
                if (extractedData.charts.length === 0) {
                    throw new Error('No valid osu!mania charts found in the archive.');
                }
                
                if (extractedData.audio.length === 0) {
                    throw new Error('No audio files found in the archive.');
                }
                
                // Show chart selection if multiple charts found
                if (extractedData.charts.length > 1) {
                    availableCharts = extractedData.charts.map((chart, index) => ({
                        ...chart,
                        index,
                        metadata: beatmapAPI.parseChartMetadata(chart.content)
                    }));
                    populateChartSelector(availableCharts);
                    document.getElementById('chart-selection').style.display = 'block';
                    showStatus('osz-status', `Extracted ${extractedData.charts.length} charts. Please select one.`);
                } else if (extractedData.charts.length === 1) {
                    // Auto-select single chart
                    await selectChart(0);
                } else {
                    throw new Error('No valid charts found in the archive.');
                }
            } catch (error) {
                showStatus('osz-status', `Error: ${error.message}`, true);
                resetOszData();
            }
        });

        function populateChartSelector(charts) {
            const selector = document.getElementById('chartSelect');
            selector.innerHTML = '';
            
            charts.forEach((chart, index) => {
                const option = document.createElement('option');
                option.value = index;
                const title = chart.metadata.title || 'Unknown Title';
                const version = chart.metadata.version || 'Unknown Difficulty';
                option.textContent = `${title} [${version}]`;
                selector.appendChild(option);
            });
            
            // Add change event listener
            selector.addEventListener('change', (e) => {
                selectChart(parseInt(e.target.value));
            });
        }

        async function selectChart(chartIndex) {
            try {
                if (!oszData || !oszData.charts[chartIndex]) {
                    throw new Error('Chart not found.');
                }

                const selectedChart = oszData.charts[chartIndex];
                chartDataFromLoader = selectedChart.content;
                
                // Setup audio - use the first audio file found
                const audioElement = document.getElementById('audioPlayer');
                const audioFile = oszData.audio[0];
                
                audioElement.src = audioFile.url;
                audioElement.load();
                
                // Wait for audio to be ready
                await new Promise((resolve, reject) => {
                    const onCanPlay = () => {
                        audioElement.removeEventListener('canplay', onCanPlay);
                        audioElement.removeEventListener('error', onError);
                        resolve();
                    };
                    const onError = () => {
                        audioElement.removeEventListener('canplay', onCanPlay);
                        audioElement.removeEventListener('error', onError);
                        reject(new Error('Failed to load audio'));
                    };
                    audioElement.addEventListener('canplay', onCanPlay);
                    audioElement.addEventListener('error', onError);
                });
                
                filesLoaded.chart = true;
                filesLoaded.audio = true;
                
                const chartInfo = availableCharts.length > 0 ? availableCharts[chartIndex] : 
                    { metadata: beatmapAPI.parseChartMetadata(selectedChart.content) };
                
                showStatus('osz-status', `Selected: ${chartInfo.metadata.title} [${chartInfo.metadata.version}]`);
                document.getElementById('start-game-btn').disabled = false;
                
            } catch (error) {
                showStatus('osz-status', `Error: ${error.message}`, true);
                resetOszData();
            }
        }

        function resetOszData() {
            oszData = null;
            availableCharts = [];
            document.getElementById('chart-selection').style.display = 'none';
            filesLoaded = { chart: false, audio: false };
            chartDataFromLoader = null;
            document.getElementById('start-game-btn').disabled = true;
        }
        
        // --- Initializer ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM Content Loaded - initializing game...');
            
            const songManager = new SongManager();
            window.songManager = songManager;
            
            // Initialize wave manager in background (non-blocking)
            if (typeof WaveAnimationManager !== 'undefined') {
                console.log('WaveAnimationManager class found, initializing wave manager...');
                try {
                    window.waveManager = new WaveAnimationManager();
                    waveManager.loadPromise.then((success) => {
                        console.log('Wave manager load result:', success);
                    }).catch((error) => {
                        console.warn('Wave manager failed to load:', error);
                    });
                } catch (error) {
                    console.error('Error creating wave manager:', error);
                }
            } else {
                console.log('WaveAnimationManager class not available');
            }
            
            const songId = songManager.getSongFromURL();
            console.log('Song ID from URL:', songId);
            
            if (songId) {
                console.log('Loading song:', songId);
                songManager.loadSongAndSetup(songId);
            } else {
                console.log('No song ID, entering custom mode');
                showGameSetup(null, null); // Enter custom mode
            }
        });

        // Show dolphin transition effect
        function showDolphinTransition(callback, duration = 2000) {
            const transition = document.createElement('div');
            transition.id = 'dolphin-transition';
            transition.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: linear-gradient(135deg, rgba(0, 60, 120, 0.95), rgba(0, 100, 160, 0.95));
                backdrop-filter: blur(10px);
                z-index: 9999;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                opacity: 0;
                transition: opacity 0.5s ease;
            `;
            
            const dolphinImg = document.createElement('img');
            dolphinImg.src = 'assets/dolphin.gif';
            dolphinImg.style.cssText = `
                width: 200px;
                height: 150px;
                object-fit: contain;
                animation: dolphinFloat 2s ease-in-out infinite;
                filter: drop-shadow(0 10px 20px rgba(0, 180, 255, 0.4));
            `;
            
            const text = document.createElement('p');
            text.textContent = 'Riding the wave...';
            text.style.cssText = `
                font-family: 'Orbitron', monospace;
                font-size: 1.5rem;
                color: #80E0FF;
                margin-top: 30px;
                text-shadow: 0 0 20px rgba(0, 180, 255, 0.6);
                animation: pulse 2s ease-in-out infinite;
            `;
            
            // Add dolphin float animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes dolphinFloat {
                    0%, 100% { transform: translateY(0px) rotate(-2deg); }
                    50% { transform: translateY(-15px) rotate(2deg); }
                }
            `;
            document.head.appendChild(style);
            
            transition.appendChild(dolphinImg);
            transition.appendChild(text);
            document.body.appendChild(transition);
            
            // Fade in
            setTimeout(() => {
                transition.style.opacity = '1';
            }, 50);
            
            // Execute callback and fade out
            setTimeout(() => {
                if (callback) callback();
                
                setTimeout(() => {
                    transition.style.opacity = '0';
                    setTimeout(() => {
                        if (transition.parentNode) {
                            transition.parentNode.removeChild(transition);
                        }
                    }, 500);
                }, 200);
            }, duration);
        }
    </script>
</body>
</html>