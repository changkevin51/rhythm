<!doctype html>
<html lang="en">
<head>
    <title>Tidal Beats - Game</title>
    <meta charset="UTF-8">
    <meta name="description" content="Rhythm game">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Exo+2:wght@300;400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="game.css">
</head>
<body>
    <!-- Settings Modal -->
    <div id="settings-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Game Settings</h2>
                <button class="modal-close" id="close-settings">&times;</button>
            </div>
            <div class="modal-body">
                <div class="settings-tabs">
                    <button class="tab-btn active" data-tab="gameplay">Gameplay</button>
                    <button class="tab-btn" data-tab="audio">Audio</button>
                    <button class="tab-btn" data-tab="visual">Visual</button>
                    <button class="tab-btn" data-tab="controls">Controls</button>
                </div>
                
                <div class="settings-content">
                    <!-- Gameplay Settings -->
                    <div id="gameplay-tab" class="tab-content active">
                        <div class="setting-group">
                            <label for="scroll-speed-setting">Scroll Speed:</label>
                            <div class="setting-input-group">
                                <input type="range" id="scroll-speed-setting" min="200" max="1000" step="25">
                                <span class="setting-value" id="scroll-speed-value">500</span>
                            </div>
                        </div>
                        <div class="setting-group">
                            <label for="offset-setting">Manual Offset (ms):</label>
                            <div class="setting-input-group">
                                <input type="range" id="offset-setting" min="-200" max="200" step="5">
                                <span class="setting-value" id="offset-value">0</span>
                            </div>
                        </div>
                        <div class="setting-group">
                            <label for="scale-setting">Note Scale (%):</label>
                            <div class="setting-input-group">
                                <input type="range" id="scale-setting" min="50" max="150" step="5">
                                <span class="setting-value" id="scale-value">100</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Audio Settings -->
                    <div id="audio-tab" class="tab-content">
                        <div class="setting-group">
                            <label for="master-volume-setting">Master Volume:</label>
                            <div class="setting-input-group">
                                <input type="range" id="master-volume-setting" min="0" max="100" step="5">
                                <span class="setting-value" id="master-volume-value">100</span>
                            </div>
                        </div>
                        <div class="setting-group">
                            <label for="music-volume-setting">Music Volume:</label>
                            <div class="setting-input-group">
                                <input type="range" id="music-volume-setting" min="0" max="100" step="5">
                                <span class="setting-value" id="music-volume-value">90</span>
                            </div>
                        </div>
                        <div class="setting-group">
                            <label for="effects-volume-setting">Effects Volume:</label>
                            <div class="setting-input-group">
                                <input type="range" id="effects-volume-setting" min="0" max="100" step="5">
                                <span class="setting-value" id="effects-volume-value">80</span>
                            </div>
                        </div>
                        <div class="calibration-section">
                            <h3>Audio Calibration</h3>
                            <div class="calibration-info">
                                <p id="calibration-status">Not calibrated</p>
                                <p id="current-audio-offset">Current offset: 0ms</p>
                            </div>
                            <button class="btn secondary" id="start-calibration-btn">Calibrate Audio</button>
                        </div>
                    </div>
                    
                    <!-- Visual Settings -->
                    <div id="visual-tab" class="tab-content">
                        <div class="setting-group">
                            <label for="background-dim-setting">Background Dim (%):</label>
                            <div class="setting-input-group">
                                <input type="range" id="background-dim-setting" min="0" max="100" step="5">
                                <span class="setting-value" id="background-dim-value">20</span>
                            </div>
                        </div>
                        <div class="setting-group checkbox-group">
                            <label class="checkbox-label">
                                <input type="checkbox" id="show-fps-setting">
                                <span class="checkmark"></span>
                                Show FPS
                            </label>
                        </div>
                        <div class="setting-group checkbox-group">
                            <label class="checkbox-label">
                                <input type="checkbox" id="particle-effects-setting" checked>
                                <span class="checkmark"></span>
                                Particle Effects
                            </label>
                        </div>
                        <div class="setting-group checkbox-group">
                            <label class="checkbox-label">
                                <input type="checkbox" id="screen-shake-setting" checked>
                                <span class="checkmark"></span>
                                Screen Shake
                            </label>
                        </div>
                    </div>
                    
                    <!-- Controls Settings -->
                    <div id="controls-tab" class="tab-content">
                        <div class="setting-group">
                            <label>Key Layout:</label>
                            <div class="key-layout-selector">
                                <select id="key-layout-select">
                                    <option value="DFJK">D-F-J-K (Default)</option>
                                    <option value="ASDF">A-S-D-F</option>
                                    <option value="HJKL">H-J-K-L</option>
                                    <option value="1234">1-2-3-4</option>
                                    <option value="ZXCV">Z-X-C-V</option>
                                    <option value="QWER">Q-W-E-R</option>
                                </select>
                            </div>
                        </div>
                        <div class="setting-group">
                            <label>Current Keys:</label>
                            <div class="key-display" id="current-keys-display">D - F - J - K</div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn secondary" id="reset-settings-btn">Reset to Defaults</button>
                <button class="btn primary" id="save-settings-btn">Save Settings</button>
            </div>
        </div>
    </div>

    <div class="game-header">
        <div class="song-info">
            <h1 id="song-title">Loading...</h1>
            <p><span id="song-artist"></span><span id="song-difficulty" class="difficulty-badge"></span></p>
        </div>
        <div class="header-controls">
            <button class="btn" id="open-settings-btn">Settings</button>
            <a class="btn" href="index.html">Change Song</a>
        </div>
    </div>

    <div class="main-content">
        <div id="loading-screen" class="loading-screen active">
            <p>Loading song...</p>
        </div>

        <div id="game-setup" class="game-setup">
            <h2 id="setup-title">Game Settings</h2>
            
            <!-- Custom Upload Section - Main Container 1 -->
            <div id="custom-upload-section" style="display:none;">
                <div class="upload-header">
                    <h3>Load Your Music</h3>
                    <p>Upload your own beatmap files to play custom songs</p>
                </div>
                
                <div class="upload-mode-selector">
                    <button class="mode-btn active" onclick="switchUploadMode('individual')">Individual Files</button>
                    <button class="mode-btn" onclick="switchUploadMode('osz')">OSZ Archive</button>
                </div>
                
                <div id="individual-upload" class="upload-section active">
                    <div class="upload-grid">
                        <div class="form-group">
                            <label for="uploadOsu">Chart File (.osu / .txt):</label>
                            <input type="file" id="uploadOsu" class="custom-file-input" accept=".osu,.txt">
                            <label for="uploadOsu" class="file-input-label">
                                <span class="file-icon">📊</span>
                                <span class="file-text">Choose Chart File</span>
                            </label>
                            <div id="chart-status" class="file-status" style="display:none;"></div>
                        </div>
                        <div class="form-group">
                            <label for="uploadAudio">Audio File (.mp3, .ogg, .wav):</label>
                            <input type="file" id="uploadAudio" class="custom-file-input" accept=".mp3,.wav,.ogg">
                            <label for="uploadAudio" class="file-input-label">
                                <span class="file-icon">🎵</span>
                                <span class="file-text">Choose Audio File</span>
                            </label>
                            <div id="audio-status" class="file-status" style="display:none;"></div>
                        </div>
                    </div>
                </div>
                
                <div id="osz-upload" class="upload-section">
                    <div class="form-group">
                        <label for="uploadOsz">OSZ Archive (.osz):</label>
                        <input type="file" id="uploadOsz" class="custom-file-input" accept=".osz">
                        <label for="uploadOsz" class="file-input-label">
                            <span class="file-icon">📦</span>
                            <span class="file-text">Choose OSZ File</span>
                        </label>
                        <div id="osz-status" class="file-status" style="display:none;"></div>
                    </div>
                </div>
            </div>

            <!-- Difficulty Selection Container - Main Container 2 -->
            <div id="difficulty-selection-container" style="display:none;">
                <div class="difficulty-header">
                    <h3>Select Difficulty</h3>
                    <p>Choose your preferred difficulty level</p>
                </div>
                
                <div id="chart-selection">
                    <label>Available Charts:</label>
                    <div id="chart-preview-container" style="margin-top: 10px;">
                        <div id="charts-found-count" style="color: #80E0FF; font-size: 0.9rem; margin-bottom: 10px;"></div>
                        <button id="select-chart-btn" class="btn primary" style="width: 100%; padding: 15px; margin-bottom: 10px;">
                            Select Difficulty
                        </button>
                        <div id="selected-chart-info" style="display: none; background: rgba(0, 212, 255, 0.1); border: 1px solid rgba(0, 212, 255, 0.3); border-radius: 8px; padding: 10px; margin-top: 10px;">
                            <div id="selected-chart-title" style="font-weight: bold; color: #00d4ff; margin-bottom: 5px;"></div>
                            <div id="selected-chart-details" style="font-size: 0.9em; color: #ccc;"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Settings Divider - Hidden by default, shown after file selection -->
            <div class="settings-divider" id="settings-divider" style="display: none;">
                <span>Game Settings</span>
            </div>

            <!-- Game Settings Grid - Hidden by default, shown after file selection -->
            <div class="game-settings-grid" id="game-settings-grid" style="display: none;">
                <div class="setting-card">
                    <label for="inputScale">Display Scale</label>
                    <div class="input-with-unit">
                        <input type="range" id="inputScale" min="50" max="150" step="5">
                        <span class="unit-display" id="scale-display">100%</span>
                    </div>
                    <div class="setting-description">Adjust the size of notes and interface elements</div>
                </div>
                
                <div class="setting-card">
                    <label for="scrollDurationInput">Scroll Speed</label>
                    <div class="input-with-unit">
                        <input type="range" id="scrollDurationInput" min="200" max="1000" step="25">
                        <span class="unit-display" id="speed-display">500</span>
                    </div>
                    <div class="setting-description">How fast notes scroll down the screen</div>
                </div>
                
                <div class="setting-card">
                    <label for="inputOffset">Total Offset</label>
                    <div class="input-with-unit">
                        <input type="range" id="inputOffset" min="-200" max="200" step="5">
                        <span class="unit-display" id="offset-display">0ms</span>
                    </div>
                    <div class="setting-description">
                        <span id="offset-breakdown">Manual: 0ms + Audio Calibration: 0ms</span>
                        <br><small>Positive values = notes appear earlier</small>
                    </div>
                </div>
                
                <div class="setting-card">
                    <label for="baseBPM">Base BPM</label>
                    <div class="input-with-unit">
                        <input type="number" id="baseBPM" placeholder="Auto-detect" min="60" max="300">
                        <span class="unit-display">BPM</span>
                    </div>
                    <div class="setting-description">Override auto-detected tempo (optional)</div>
                </div>
            </div>
            
            <div class="quick-settings" id="quick-settings" style="display: none;">
                <div class="quick-setting-item">
                    <label class="checkbox-label">
                        <input type="checkbox" id="auto-play-setup">
                        <span class="checkmark"></span>
                        Auto Play
                    </label>
                </div>
                <div class="quick-setting-item">
                    <label class="checkbox-label">
                        <input type="checkbox" id="no-fail-setup">
                        <span class="checkmark"></span>
                        No Fail
                    </label>
                </div>
            </div>
            
            <div class="button-wrapper" style="width: 100%; text-align: center; padding: 20px 0;">
                <div class="start-button-container">
                    <button class="btn primary large" id="start-game-btn">Start Game</button>
                </div>
            </div>
        </div>

        <div id="game-container" class="game-container">
            <canvas id="myCanvas" width="600" height="800"></canvas>
            <div class="combo-display">0</div>
        </div>
    </div>

    <audio id="audioPlayer" preload="auto"></audio>

    <!-- JSZip library for handling .osz files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="js/SettingsManager.js"></script>
    <script src="js/SongManager.js"></script>
    <script src="js/WaveAnimationManager.js"></script>
    <script src="js/SplashAnimationManager.js"></script>
    <script src="js/GameplayEnhancer.js"></script>
    <script src="js/Game_Pre.js"></script>

    <script>
        let chartDataFromLoader = null;
        let filesLoaded = { chart: false, audio: false };
        let currentUploadMode = 'individual';
        let oszData = null;
        let availableCharts = [];

        // Fallback validation functions if GameUtils is not available
        const BeatmapUtils = {
            isValidChartFile(file) {
                const validExtensions = ['.osu', '.txt'];
                const fileName = file.name.toLowerCase();
                return validExtensions.some(ext => fileName.endsWith(ext));
            },

            isValidAudioFile(file) {
                const validExtensions = ['.mp3', '.wav', '.ogg'];
                const fileName = file.name.toLowerCase();
                return validExtensions.some(ext => fileName.endsWith(ext));
            },

            isValidArchive(file) {
                const fileName = file.name.toLowerCase();
                return fileName.endsWith('.osz') || fileName.endsWith('.zip');
            },

            async readChartFile(file) {
                return new Promise((resolve, reject) => {
                    if (!this.isValidChartFile(file)) {
                        reject(new Error('Invalid chart file format. Please use .osu or .txt files.'));
                        return;
                    }

                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const content = event.target.result;
                            
                            // Basic validation for .osu files
                            if (file.name.toLowerCase().endsWith('.osu')) {
                                const validationResult = this.validateOsuFile(content);
                                if (!validationResult.isValid) {
                                    reject(new Error(validationResult.error));
                                    return;
                                }
                            }
                            
                            resolve(content);
                        } catch (error) {
                            reject(new Error('Failed to read chart file: ' + error.message));
                        }
                    };
                    reader.onerror = () => {
                        reject(new Error('Failed to read chart file'));
                    };
                    reader.readAsText(file, 'UTF-8');
                });
            },

            validateOsuFile(content) {
                try {
                    const lines = content.split('\n').map(line => line.trim());
                    let inGeneralSection = false;
                    let modeFound = false;
                    let mode = null;

                    for (const line of lines) {
                        if (line.startsWith('[') && line.endsWith(']')) {
                            inGeneralSection = line.toLowerCase() === '[general]';
                            continue;
                        }

                        if (inGeneralSection && line.toLowerCase().startsWith('mode:')) {
                            modeFound = true;
                            mode = parseInt(line.split(':')[1].trim());
                            break;
                        }
                    }

                    if (!modeFound) {
                        return {
                            isValid: false,
                            error: 'Invalid osu! file: Mode not specified. Please ensure this is a valid osu!mania beatmap (Mode: 3).'
                        };
                    }

                    if (mode !== 3) {
                        const modeNames = {
                            0: 'osu! (Standard)',
                            1: 'Taiko',
                            2: 'Catch the Beat',
                            3: 'osu!mania'
                        };
                        
                        return {
                            isValid: false,
                            error: `Invalid game mode: This beatmap is for ${modeNames[mode] || 'Unknown mode'} (Mode: ${mode}). Please use an osu!mania beatmap (Mode: 3).`
                        };
                    }

                    return { isValid: true, mode: mode };

                } catch (error) {
                    return {
                        isValid: false,
                        error: 'Failed to parse osu! file: ' + error.message
                    };
                }
            },

            async readAudioFile(file) {
                return new Promise((resolve, reject) => {
                    if (!this.isValidAudioFile(file)) {
                        reject(new Error('Invalid audio file format. Please use .mp3, .wav, or .ogg files.'));
                        return;
                    }

                    try {
                        const audioURL = URL.createObjectURL(file);
                        resolve({
                            url: audioURL,
                            filename: file.name,
                            size: file.size,
                            type: file.type
                        });
                    } catch (error) {
                        reject(new Error('Failed to process audio file: ' + error.message));
                    }
                });
            },

            async setupAudioElement(audioElement, audioData) {
                return new Promise((resolve, reject) => {
                    if (!audioData || !audioData.url) {
                        reject(new Error('Invalid audio data'));
                        return;
                    }

                    const audio = audioElement;
                    
                    // Clear any existing source
                    audio.src = '';
                    audio.load();

                    // Set up event listeners
                    const onCanPlay = () => {
                        audio.removeEventListener('canplay', onCanPlay);
                        audio.removeEventListener('error', onError);
                        resolve(audio);
                    };

                    const onError = (e) => {
                        audio.removeEventListener('canplay', onCanPlay);
                        audio.removeEventListener('error', onError);
                        reject(new Error('Failed to load audio: ' + (e.message || 'Unknown error')));
                    };

                    audio.addEventListener('canplay', onCanPlay);
                    audio.addEventListener('error', onError);

                    // Set the source and load
                    audio.src = audioData.url;
                    audio.load();
                });
            },

            async extractOszArchive(file) {
                return new Promise((resolve, reject) => {
                    if (!this.isValidArchive(file)) {
                        reject(new Error('Invalid archive format. Please use .osz or .zip files.'));
                        return;
                    }

                    // Check if JSZip is available
                    if (typeof JSZip === 'undefined') {
                        reject(new Error('JSZip library is required for .osz support. Please reload the page.'));
                        return;
                    }

                    const reader = new FileReader();
                    reader.onload = async (event) => {
                        try {
                            const zip = new JSZip();
                            const zipData = await zip.loadAsync(event.target.result);
                            
                            const extractedFiles = {
                                charts: [],
                                audio: [],
                                images: [],
                                other: []
                            };

                            // Process each file in the archive
                            for (const [filename, fileData] of Object.entries(zipData.files)) {
                                if (fileData.dir) continue; // Skip directories

                                const lowerName = filename.toLowerCase();
                                
                                if (lowerName.endsWith('.osu')) {
                                    const content = await fileData.async('text');
                                    
                                    // Validate osu!mania mode for charts in archive
                                    const validationResult = this.validateOsuFile(content);
                                    if (validationResult.isValid) {
                                        extractedFiles.charts.push({
                                            filename,
                                            content,
                                            size: content.length,
                                            mode: validationResult.mode
                                        });
                                    } else {
                                        console.warn(`Skipping ${filename}: ${validationResult.error}`);
                                    }
                                } else if (lowerName.endsWith('.mp3') || lowerName.endsWith('.wav') || lowerName.endsWith('.ogg')) {
                                    const blob = await fileData.async('blob');
                                    extractedFiles.audio.push({
                                        filename,
                                        url: URL.createObjectURL(blob),
                                        size: blob.size,
                                        type: blob.type
                                    });
                                } else if (lowerName.endsWith('.jpg') || lowerName.endsWith('.jpeg') || lowerName.endsWith('.png')) {
                                    const blob = await fileData.async('blob');
                                    extractedFiles.images.push({
                                        filename,
                                        url: URL.createObjectURL(blob),
                                        size: blob.size
                                    });
                                }
                            }

                            resolve(extractedFiles);
                        } catch (error) {
                            reject(new Error('Failed to extract archive: ' + error.message));
                        }
                    };
                    reader.onerror = () => {
                        reject(new Error('Failed to read archive file'));
                    };
                    reader.readAsArrayBuffer(file);
                });
            },

            parseChartMetadata(content) {
                const metadata = {
                    title: 'Unknown Title',
                    artist: 'Unknown Artist',
                    creator: 'Unknown Creator',
                    version: 'Unknown Difficulty'
                };

                const lines = content.split('\n');
                let inMetadataSection = false;

                for (const line of lines) {
                    const trimmedLine = line.trim();
                    
                    if (trimmedLine.startsWith('[') && trimmedLine.endsWith(']')) {
                        inMetadataSection = trimmedLine.toLowerCase() === '[metadata]';
                        continue;
                    }

                    if (inMetadataSection && trimmedLine.includes(':')) {
                        const [key, value] = trimmedLine.split(':', 2);
                        const cleanKey = key.trim().toLowerCase();
                        const cleanValue = value.trim();

                        switch (cleanKey) {
                            case 'title':
                                metadata.title = cleanValue;
                                break;
                            case 'artist':
                                metadata.artist = cleanValue;
                                break;
                            case 'creator':
                                metadata.creator = cleanValue;
                                break;
                            case 'version':
                                metadata.version = cleanValue;
                                break;
                        }
                    }
                }

                return metadata;
            }
        };

        // --- Settings Modal Functionality ---
        class GameSettingsUI {
            constructor() {
                this.modal = document.getElementById('settings-modal');
                this.initializeElements();
                this.bindEvents();
                this.loadCurrentSettings();
            }
            
            initializeElements() {
                // Modal controls
                this.openBtn = document.getElementById('open-settings-btn');
                this.closeBtn = document.getElementById('close-settings');
                this.saveBtn = document.getElementById('save-settings-btn');
                this.resetBtn = document.getElementById('reset-settings-btn');
                
                // Tab controls
                this.tabBtns = document.querySelectorAll('.tab-btn');
                this.tabContents = document.querySelectorAll('.tab-content');
                
                // Setting inputs
                this.scrollSpeedInput = document.getElementById('scroll-speed-setting');
                this.offsetInput = document.getElementById('offset-setting');
                this.scaleInput = document.getElementById('scale-setting');
                this.masterVolumeInput = document.getElementById('master-volume-setting');
                this.musicVolumeInput = document.getElementById('music-volume-setting');
                this.effectsVolumeInput = document.getElementById('effects-volume-setting');
                this.backgroundDimInput = document.getElementById('background-dim-setting');
                this.showFpsInput = document.getElementById('show-fps-setting');
                this.particleEffectsInput = document.getElementById('particle-effects-setting');
                this.screenShakeInput = document.getElementById('screen-shake-setting');
                this.keyLayoutSelect = document.getElementById('key-layout-select');
                
                // Display elements
                this.scrollSpeedValue = document.getElementById('scroll-speed-value');
                this.offsetValue = document.getElementById('offset-value');
                this.scaleValue = document.getElementById('scale-value');
                this.masterVolumeValue = document.getElementById('master-volume-value');
                this.musicVolumeValue = document.getElementById('music-volume-value');
                this.effectsVolumeValue = document.getElementById('effects-volume-value');
                this.backgroundDimValue = document.getElementById('background-dim-value');
                this.currentKeysDisplay = document.getElementById('current-keys-display');
                this.calibrationStatus = document.getElementById('calibration-status');
                this.currentAudioOffset = document.getElementById('current-audio-offset');
                this.startCalibrationBtn = document.getElementById('start-calibration-btn');
            }
            
            bindEvents() {
                // Modal controls
                this.openBtn.addEventListener('click', () => this.openModal());
                this.closeBtn.addEventListener('click', () => this.closeModal());
                this.saveBtn.addEventListener('click', () => this.saveSettings());
                this.resetBtn.addEventListener('click', () => this.resetSettings());
                
                // Tab switching
                this.tabBtns.forEach(btn => {
                    btn.addEventListener('click', () => this.switchTab(btn.dataset.tab));
                });
                
                // Range input updates
                this.setupRangeInput(this.scrollSpeedInput, this.scrollSpeedValue);
                this.setupRangeInput(this.offsetInput, this.offsetValue, 'ms');
                this.setupRangeInput(this.scaleInput, this.scaleValue, '%');
                this.setupRangeInput(this.masterVolumeInput, this.masterVolumeValue, '%');
                this.setupRangeInput(this.musicVolumeInput, this.musicVolumeValue, '%');
                this.setupRangeInput(this.effectsVolumeInput, this.effectsVolumeValue, '%');
                this.setupRangeInput(this.backgroundDimInput, this.backgroundDimValue, '%');
                
                // Key layout change
                this.keyLayoutSelect.addEventListener('change', () => this.updateKeyDisplay());
                
                // Calibration
                this.startCalibrationBtn.addEventListener('click', () => this.startCalibration());
                
                // Close modal on outside click
                this.modal.addEventListener('click', (e) => {
                    if (e.target === this.modal) this.closeModal();
                });
            }
            
            setupRangeInput(input, display, unit = '') {
                input.addEventListener('input', () => {
                    display.textContent = input.value + unit;
                });
            }
            
            switchTab(tabName) {
                // Update tab buttons
                this.tabBtns.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.tab === tabName);
                });
                
                // Update tab contents
                this.tabContents.forEach(content => {
                    content.classList.toggle('active', content.id === tabName + '-tab');
                });
            }
            
            loadCurrentSettings() {
                const settings = gameSettings.getAll();
                
                // Load values
                this.scrollSpeedInput.value = settings.scrollSpeed;
                this.offsetInput.value = settings.offset;
                this.scaleInput.value = settings.scale;
                this.masterVolumeInput.value = settings.masterVolume;
                this.musicVolumeInput.value = settings.musicVolume;
                this.effectsVolumeInput.value = settings.effectsVolume;
                this.backgroundDimInput.value = settings.backgroundDim;
                this.showFpsInput.checked = settings.showFPS;
                this.particleEffectsInput.checked = settings.particleEffects;
                this.screenShakeInput.checked = settings.screenShake;
                this.keyLayoutSelect.value = settings.keyLayout;
                
                // Update displays
                this.scrollSpeedValue.textContent = settings.scrollSpeed;
                this.offsetValue.textContent = settings.offset + 'ms';
                this.scaleValue.textContent = settings.scale + '%';
                this.masterVolumeValue.textContent = settings.masterVolume + '%';
                this.musicVolumeValue.textContent = settings.musicVolume + '%';
                this.effectsVolumeValue.textContent = settings.effectsVolume + '%';
                this.backgroundDimValue.textContent = settings.backgroundDim + '%';
                
                this.updateKeyDisplay();
                this.updateCalibrationStatus();
            }
            
            updateKeyDisplay() {
                const layout = this.keyLayoutSelect.value;
                const preset = gameSettings.keyPresets[layout];
                if (preset) {
                    const keyNames = preset.keys.map(key => gameSettings.getKeyName(key));
                    this.currentKeysDisplay.textContent = keyNames.join(' - ');
                }
            }
            
            updateCalibrationStatus() {
                const isCalibrated = gameSettings.get('isCalibrated');
                const audioOffset = gameSettings.get('audioOffset');
                
                if (isCalibrated) {
                    this.calibrationStatus.textContent = 'Audio calibrated ✓';
                    this.calibrationStatus.style.color = '#00FFAA';
                } else {
                    this.calibrationStatus.textContent = 'Not calibrated';
                    this.calibrationStatus.style.color = '#FF6464';
                }
                
                this.currentAudioOffset.textContent = `Current offset: ${audioOffset}ms`;
            }
            
            saveSettings() {
                const updates = {
                    scrollSpeed: parseInt(this.scrollSpeedInput.value),
                    offset: parseInt(this.offsetInput.value),
                    scale: parseInt(this.scaleInput.value),
                    masterVolume: parseInt(this.masterVolumeInput.value),
                    musicVolume: parseInt(this.musicVolumeInput.value),
                    effectsVolume: parseInt(this.effectsVolumeInput.value),
                    backgroundDim: parseInt(this.backgroundDimInput.value),
                    showFPS: this.showFpsInput.checked,
                    particleEffects: this.particleEffectsInput.checked,
                    screenShake: this.screenShakeInput.checked,
                    keyLayout: this.keyLayoutSelect.value
                };
                
                gameSettings.setMultiple(updates);
                gameSettings.setKeyLayout(this.keyLayoutSelect.value);
                
                // Update game setup inputs if they exist
                this.updateGameSetupInputs();
                
                this.closeModal();
                this.showNotification('Settings saved successfully!');
            }
            
            resetSettings() {
                if (confirm('Reset all settings to defaults? This action cannot be undone.')) {
                    gameSettings.resetToDefaults();
                    this.loadCurrentSettings();
                    this.updateGameSetupInputs();
                    this.showNotification('Settings reset to defaults');
                }
            }
            
            updateGameSetupInputs() {
                // Update the game setup inputs to reflect new settings
                const setupScale = document.getElementById('inputScale');
                const setupSpeed = document.getElementById('scrollDurationInput');
                const setupOffset = document.getElementById('inputOffset');
                
                if (setupScale) setupScale.value = gameSettings.get('scale');
                if (setupSpeed) setupSpeed.value = gameSettings.get('scrollSpeed');
                if (setupOffset) {
                    const totalOffset = gameSettings.getEffectiveOffset();
                    setupOffset.value = totalOffset;
                    updateOffsetDisplay();
                }
                
                updateGameSetupDisplays();
            }
            
            startCalibration() {
                this.closeModal();
                
                // Create and show calibration overlay similar to index.html
                this.createCalibrationOverlay();
            }
            
            createCalibrationOverlay() {
                // Remove existing overlay if any
                const existing = document.getElementById('game-calibration-overlay');
                if (existing) existing.remove();
                
                // Create calibration overlay
                const overlay = document.createElement('div');
                overlay.id = 'game-calibration-overlay';
                overlay.className = 'calibration-overlay active';
                
                overlay.innerHTML = `
                    <div class="calibration-modal">
                        <h2 class="calibration-title">Audio Offset Calibration</h2>
                        <p class="calibration-description">
                            Let's calibrate your audio offset for the best rhythm game experience!<br>
                            This will help synchronize the audio with your input for perfect timing.<br>
                            <small style="color: #80E0FF; margin-top: 0.5rem; display: block;">
                                Don't worry if you miss the first few beats - the calibration focuses on your most recent consistent taps.
                            </small>
                        </p>
                        
                        <div class="metronome-container">
                            <div id="game-metronome-beat" class="metronome-beat"></div>
                        </div>
                        
                        <div class="calibration-instructions">
                            Press <span class="calibration-key">D</span> in sync with the beat
                        </div>
                        
                        <div class="calibration-progress">
                            <div id="game-calibration-progress-fill" class="calibration-progress-fill"></div>
                        </div>
                        
                        <div id="game-calibration-stats" class="calibration-stats">
                            <div class="stat-row">
                                <span>Taps recorded:</span>
                                <span class="stat-value" id="game-taps-count">0</span>
                            </div>
                            <div class="stat-row">
                                <span>Average offset:</span>
                                <span class="stat-value" id="game-avg-offset">0ms</span>
                            </div>
                            <div class="stat-row">
                                <span>Consistency:</span>
                                <span class="stat-value" id="game-consistency">0%</span>
                            </div>
                        </div>
                        
                        <div class="calibration-buttons">
                            <button id="game-start-calibration" class="btn primary">Start Calibration</button>
                            <button id="game-finish-calibration" class="btn" style="display: none;">Save & Continue</button>
                            <button id="game-skip-calibration" class="btn">Skip for Now</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(overlay);
                
                // Initialize the calibration system
                this.initGameCalibration();
            }
            
            async initGameCalibration() {
                this.isCalibrating = false;
                this.audioContext = null;
                this.metronomeGain = null;
                this.metronomeOscillator = null;
                this.bpm = 120;
                this.beatInterval = 60000 / this.bpm;
                this.startTime = 0;
                this.beatCount = 0;
                this.tapOffsets = [];
                this.beatTimes = [];
                this.tappedBeats = new Set();
                this.minTaps = 8;
                this.maxTaps = 20;
                this.targetTaps = 12;
                
                // Bind events
                document.getElementById('game-start-calibration').addEventListener('click', () => this.startGameCalibration());
                document.getElementById('game-finish-calibration').addEventListener('click', () => this.finishGameCalibration());
                document.getElementById('game-skip-calibration').addEventListener('click', () => this.skipGameCalibration());
                
                // Key listener for D key
                this.calibrationKeyListener = (e) => {
                    if (this.isCalibrating && e.code === 'KeyD') {
                        this.recordGameTap();
                    }
                };
                document.addEventListener('keydown', this.calibrationKeyListener);
            }
            
            async startGameCalibration() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.metronomeGain = this.audioContext.createGain();
                    this.metronomeGain.connect(this.audioContext.destination);
                    this.metronomeGain.gain.value = 0.3;
                    
                    this.isCalibrating = true;
                    this.tapOffsets = [];
                    this.beatTimes = [];
                    this.tappedBeats.clear();
                    this.beatCount = 0;
                    this.startTime = this.audioContext.currentTime;
                    
                    document.getElementById('game-start-calibration').style.display = 'none';
                    document.getElementById('game-calibration-stats').classList.add('active');
                    
                    this.runGameMetronome();
                } catch (error) {
                    alert('Unable to start audio calibration. Please ensure your browser supports Web Audio API.');
                }
            }
            
            runGameMetronome() {
                if (!this.isCalibrating) return;
                
                this.playGameBeat();
                this.beatCount++;
                
                if (this.beatCount < this.maxTaps + 5) {
                    setTimeout(() => this.runGameMetronome(), this.beatInterval);
                } else {
                    this.isCalibrating = false;
                    document.getElementById('game-finish-calibration').style.display = 'block';
                }
            }
            
            playGameBeat() {
                const oscillator = this.audioContext.createOscillator();
                oscillator.connect(this.metronomeGain);
                oscillator.frequency.value = 800;
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.1);
                
                const beatElement = document.getElementById('game-metronome-beat');
                beatElement.classList.add('active');
                setTimeout(() => beatElement.classList.remove('active'), 100);
                
                this.beatTimes.push(Date.now());
            }
            
            recordGameTap() {
                const tapTime = Date.now();
                if (!this.beatTimes.length) return;

                let closestBeatIndex = -1;
                let minDiff = Infinity;

                // Find the beat with the minimum time difference
                for (let i = 0; i < this.beatTimes.length; i++) {
                    const diff = Math.abs(tapTime - this.beatTimes[i]);
                    if (diff < minDiff) {
                        minDiff = diff;
                        closestBeatIndex = i;
                    }
                }

                // Ignore tap if it's too far from any beat (more than half a beat interval)
                if (minDiff > this.beatInterval / 2) {
                    console.log(`Ignoring tap, too far from beat: ${minDiff}ms`);
                    return;
                }

                // Ignore tap if this beat has already been matched
                if (this.tappedBeats.has(closestBeatIndex)) {
                    console.log(`Ignoring tap, beat ${closestBeatIndex} already has a tap.`);
                    return;
                }

                const offset = tapTime - this.beatTimes[closestBeatIndex];
                this.tapOffsets.push(offset);
                this.tappedBeats.add(closestBeatIndex);

                this.updateGameStats();
                this.updateGameProgress();
            }
            
            updateGameStats() {
                const tapsCount = document.getElementById('game-taps-count');
                const avgOffset = document.getElementById('game-avg-offset');
                const consistency = document.getElementById('game-consistency');
                
                tapsCount.textContent = this.tapOffsets.length;
                
                if (this.tapOffsets.length >= 3) {
                    const offset = this.calculateGameOffset();
                    const consistencyValue = this.calculateGameConsistency();
                    
                    avgOffset.textContent = Math.round(offset) + 'ms';
                    consistency.textContent = Math.round(consistencyValue) + '%';
                    
                    // Show which taps are being used for calculation
                    const windowSize = Math.min(10, this.tapOffsets.length);
                    if (this.tapOffsets.length >= 3) {
                        avgOffset.title = `Average of last ${windowSize} taps`;
                        consistency.title = `Consistency of last ${windowSize} taps`;
                    }
                }
            }
            
            updateGameProgress() {
                const progress = Math.min(this.tapOffsets.length / this.targetTaps, 1) * 100;
                document.getElementById('game-calibration-progress-fill').style.width = progress + '%';
            }
            
            calculateGameOffset() {
                if (this.tapOffsets.length < 3) return 0;
                
                // Use only the last 8-10 taps (sliding window approach)
                const windowSize = Math.min(10, this.tapOffsets.length);
                const startIndex = Math.max(0, this.tapOffsets.length - windowSize);
                const recentOffsets = this.tapOffsets.slice(startIndex);
                
                // Calculate simple average of recent taps
                const sum = recentOffsets.reduce((a, b) => a + b, 0);
                return Math.round(sum / recentOffsets.length);
            }
            
            calculateGameConsistency() {
                if (this.tapOffsets.length < 3) return 0;
                
                // Use only the last 8-10 taps (sliding window approach)
                const windowSize = Math.min(10, this.tapOffsets.length);
                const startIndex = Math.max(0, this.tapOffsets.length - windowSize);
                const recentOffsets = this.tapOffsets.slice(startIndex);
                
                // Calculate standard deviation of recent taps
                const mean = recentOffsets.reduce((a, b) => a + b, 0) / recentOffsets.length;
                const variance = recentOffsets.reduce((sum, offset) => sum + Math.pow(offset - mean, 2), 0) / recentOffsets.length;
                const stdDev = Math.sqrt(variance);
                
                // Convert standard deviation to consistency percentage
                // Lower stdDev = higher consistency (0ms stdDev = 100%, increases as stdDev gets worse)
                return Math.max(0, Math.min(100, 100 - (stdDev / 15)));
            }
            
            finishGameCalibration() {
                this.isCalibrating = false;
                
                if (this.tapOffsets.length >= this.minTaps) {
                    const offset = this.calculateGameOffset();
                    const savedOffset = gameSettings.saveCalibration(offset);
                    
                    this.removeCalibrationOverlay();
                    this.updateCalibrationStatus();
                    this.showNotification(`Audio calibration saved! Offset: ${savedOffset}ms`);
                } else {
                    this.showNotification('Not enough taps recorded. Please try again.', true);
                }
            }
            
            skipGameCalibration() {
                this.isCalibrating = false;
                this.removeCalibrationOverlay();
            }
            
            removeCalibrationOverlay() {
                const overlay = document.getElementById('game-calibration-overlay');
                if (overlay) {
                    document.removeEventListener('keydown', this.calibrationKeyListener);
                    overlay.remove();
                }
                
                if (this.audioContext) {
                    this.audioContext.close();
                    this.audioContext = null;
                }
            }
            
            openModal() {
                this.modal.classList.add('active');
                this.loadCurrentSettings(); // Refresh values
            }
            
            closeModal() {
                this.modal.classList.remove('active');
            }
            
            showNotification(message, isError = false) {
                // Create a simple notification
                const notification = document.createElement('div');
                notification.className = `notification ${isError ? 'error' : 'success'}`;
                notification.textContent = message;
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: ${isError ? 'rgba(255, 100, 100, 0.9)' : 'rgba(0, 255, 170, 0.9)'};
                    color: white;
                    padding: 15px 20px;
                    border-radius: 10px;
                    z-index: 3000;
                    font-family: 'Orbitron', monospace;
                    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
                    transform: translateX(100%);
                    transition: transform 0.3s ease;
                `;
                
                document.body.appendChild(notification);
                
                // Animate in
                setTimeout(() => {
                    notification.style.transform = 'translateX(0)';
                }, 10);
                
                // Remove after delay
                setTimeout(() => {
                    notification.style.transform = 'translateX(100%)';
                    setTimeout(() => {
                        document.body.removeChild(notification);
                    }, 300);
                }, 3000);
            }
        }
        
        // --- Enhanced Game Setup Functionality ---
        function initializeGameSetup() {
            const settings = gameSettings.getAll();
            
            // Set default values from settings
            const scaleInput = document.getElementById('inputScale');
            const speedInput = document.getElementById('scrollDurationInput');
            const offsetInput = document.getElementById('inputOffset');
            const scaleDisplay = document.getElementById('scale-display');
            const speedDisplay = document.getElementById('speed-display');
            const offsetDisplay = document.getElementById('offset-display');
            const offsetBreakdown = document.getElementById('offset-breakdown');
            
            if (scaleInput) {
                scaleInput.value = settings.scale;
                scaleInput.addEventListener('input', updateGameSetupDisplays);
            }
            
            if (speedInput) {
                speedInput.value = settings.scrollSpeed;
                speedInput.addEventListener('input', updateGameSetupDisplays);
            }
            
            if (offsetInput) {
                // Use the audio calibration offset as the default for new games
                const defaultOffset = gameSettings.getDefaultGameOffset();
                offsetInput.value = defaultOffset;
                offsetInput.addEventListener('input', updateOffsetDisplay);
                
                // Log for debugging
                console.log('Setting default offset to:', defaultOffset);
                console.log('Audio calibration offset:', gameSettings.get('audioOffset'));
            }
            
            updateGameSetupDisplays();
            updateOffsetDisplay();
            
            // Setup scroll detection for better UX
            setupScrollDetection();
        }
        
        function setupScrollDetection() {
            const gameSetup = document.getElementById('game-setup');
            const customUploadSection = document.getElementById('custom-upload-section');
            const gameSettingsGrid = document.querySelector('.game-settings-grid');
            
            function checkScrollable(element) {
                if (!element) return;
                
                const hasScroll = element.scrollHeight > element.clientHeight;
                element.classList.toggle('has-scroll', hasScroll);
                
                // Add scroll event listener for fade effect
                if (hasScroll) {
                    element.addEventListener('scroll', () => {
                        const isNearBottom = element.scrollTop + element.clientHeight >= element.scrollHeight - 10;
                        element.classList.toggle('scrolled-to-bottom', isNearBottom);
                    });
                }
            }
            
            // Check all scrollable elements
            setTimeout(() => {
                checkScrollable(gameSetup);
                checkScrollable(customUploadSection);
                checkScrollable(gameSettingsGrid);
            }, 100);
            
            // Recheck on window resize
            window.addEventListener('resize', () => {
                setTimeout(() => {
                    checkScrollable(gameSetup);
                    checkScrollable(customUploadSection);
                    checkScrollable(gameSettingsGrid);
                }, 100);
            });
        }
        
        function updateGameSetupDisplays() {
            const scaleInput = document.getElementById('inputScale');
            const speedInput = document.getElementById('scrollDurationInput');
            const scaleDisplay = document.getElementById('scale-display');
            const speedDisplay = document.getElementById('speed-display');
            
            if (scaleInput && scaleDisplay) {
                scaleDisplay.textContent = scaleInput.value + '%';
            }
            
            if (speedInput && speedDisplay) {
                speedDisplay.textContent = speedInput.value;
            }
        }
        
        function updateOffsetDisplay() {
            const offsetInput = document.getElementById('inputOffset');
            const offsetDisplay = document.getElementById('offset-display');
            const offsetBreakdown = document.getElementById('offset-breakdown');
            
            if (offsetInput && offsetDisplay) {
                const totalOffset = parseInt(offsetInput.value);
                const audioOffset = gameSettings.get('audioOffset');
                const manualOffset = totalOffset - audioOffset;
                
                offsetDisplay.textContent = totalOffset + 'ms';
                
                if (offsetBreakdown) {
                    offsetBreakdown.innerHTML = `Manual: ${manualOffset}ms + Audio Calibration: ${audioOffset}ms`;
                }
            }
        }

        // Use GameUtils if available, otherwise use fallback
        const beatmapAPI = (typeof GameUtils !== 'undefined' && GameUtils.beatmap) ? GameUtils.beatmap : BeatmapUtils;
        
        // Make beatmapAPI globally available for SongManager
        window.beatmapAPI = beatmapAPI;

        // Upload mode switching
        function switchUploadMode(mode) {
            currentUploadMode = mode;
            
            // Update button states
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // Show/hide sections
            document.querySelectorAll('.upload-section').forEach(section => section.classList.remove('active'));
            document.getElementById(mode === 'individual' ? 'individual-upload' : 'osz-upload').classList.add('active');
            
            // Reset states
            resetUploadStates();
        }

        function resetUploadStates() {
            filesLoaded = { chart: false, audio: false };
            chartDataFromLoader = null;
            oszData = null;
            availableCharts = [];
            document.getElementById('start-game-btn').disabled = true;
            
            // Clear background image
            clearBackgroundImage();
            
            // Hide all status messages
            document.querySelectorAll('.file-status').forEach(status => {
                status.style.display = 'none';
            });
            
            // Reset file inputs
            document.querySelectorAll('input[type="file"]').forEach(input => {
                input.value = '';
            });
            
            // Hide game settings
            hideGameSettings();
        }

        function showStatus(elementId, message, isError = false) {
            const statusDiv = document.getElementById(elementId);
            statusDiv.textContent = message;
            statusDiv.className = `file-status ${isError ? 'error' : 'success'}`;
            statusDiv.style.display = 'block';
        }

        // This function is the main entry point after files are ready.
        function showGameSetup(chartText, songTitle) {
            chartDataFromLoader = chartText;

            // Show setup screen
            document.getElementById('loading-screen').classList.remove('active');
            const setupScreen = document.getElementById('game-setup');
            setupScreen.classList.add('active');
            document.getElementById('setup-title').textContent = songTitle || "Custom Song";

            // Initialize the enhanced game setup
            initializeGameSetup();

            // If chartText is null, it means we are in custom upload mode.
            if (!chartText) {
                // Clear background image for custom uploads
                clearBackgroundImage();
                
                document.getElementById('custom-upload-section').style.display = 'block';
                setupScreen.classList.add('has-custom-upload');
                document.getElementById('start-game-btn').disabled = true;
                
                // Update title for custom mode
                document.getElementById('setup-title').textContent = "Custom Song Setup";
            } else {
                document.getElementById('custom-upload-section').style.display = 'none';
                setupScreen.classList.remove('has-custom-upload');
                document.getElementById('start-game-btn').disabled = false;
            }
        }

        // The button click handler for starting the game
        document.getElementById('start-game-btn').addEventListener('click', async () => {
            if (!chartDataFromLoader && !filesLoaded.chart) {
                alert("Chart data not loaded! Please select a song or upload a file.");
                return;
            }

            console.log('Start game button clicked, preparing to start...');
            
            // Disable the start button to prevent multiple clicks
            const startBtn = document.getElementById('start-game-btn');
            startBtn.disabled = true;
            startBtn.textContent = 'Starting...';
            
            try {
                // Initialize wave manager if available and wait for it to be ready
                if (typeof waveManager !== 'undefined' && waveManager.loadPromise) {
                    console.log('Waiting for existing wave manager to be ready...');
                    await waveManager.loadPromise; // Wait for wave frames to load
                    console.log('Wave manager ready');
                } else if (typeof WaveAnimationManager !== 'undefined') {
                    console.log('Creating wave manager...');
                    window.waveManager = new WaveAnimationManager();
                    await waveManager.loadPromise; // Wait for wave frames to load
                    console.log('Wave manager ready');
                }
                
                // Small delay to ensure DOM is fully ready
                await new Promise(resolve => setTimeout(resolve, 100));
                
                console.log('Starting game now...');
                startGameNow();
                
            } catch (error) {
                console.error('Error during game initialization:', error);
                alert('Error starting game: ' + error.message);
                
                // Re-enable the button
                startBtn.disabled = false;
                startBtn.textContent = 'Start Game';
            }
        });
        
        function startGameNow() {
            console.log('Starting game now...');
            
            // Debug: Check critical elements
            const audioElement = document.getElementById('audioPlayer');
            const canvasElement = document.getElementById('myCanvas');
            console.log('Audio element exists:', !!audioElement);
            console.log('Canvas element exists:', !!canvasElement);
            console.log('Chart data exists:', !!chartDataFromLoader);
            console.log('Chart data length:', chartDataFromLoader ? chartDataFromLoader.length : 0);
            
            if (!chartDataFromLoader) {
                console.error('No chart data available!');
                alert('No chart data loaded. Please select a song first.');
                return;
            }
            
            if (!audioElement) {
                console.error('Audio element not found!');
                alert('Audio player not found. There may be an issue with the HTML.');
                return;
            }
            
            if (!canvasElement) {
                console.error('Canvas element not found!');
                alert('Game canvas not found. There may be an issue with the HTML.');
                return;
            }
            
            try {
                // 0. First initialize game elements
                if (!initializeGameElements()) {
                    throw new Error('Failed to initialize game elements (canvas, audio, etc.)');
                }
                
                // 0.5. Reset game state to ensure clean start
                resetGameState();
                
                // 1. Process the chart data using the original working function
                processChartData(chartDataFromLoader);

                // 2. Apply settings from the form if they exist
                if (document.getElementById('inputScale')) {
                    Scale = Number(document.getElementById('inputScale').value) || 100;
                }
                if (document.getElementById("scrollDurationInput")) {
                    scrollDuration = Number(document.getElementById("scrollDurationInput").value) || 500;
                }
                if (document.getElementById("inputOffset")) {
                    offset = Number(document.getElementById("inputOffset").value) || -40;
                }
                updateOffsetFromSettings(); // Update effective offset
                
                // --- THIS IS THE FIX ---
                // Get the baseMpB from the first timing point.
                const baseBPMElement = document.getElementById("baseBPM");
                if (baseBPMElement && baseBPMElement.value) {
                    // If user provides a value, use it (convert BPM to ms per beat)
                    baseMpB = 60000 / Number(baseBPMElement.value);
                    console.log(`User-provided baseMpB: ${baseMpB} (from ${baseBPMElement.value} BPM)`);
                } else {
                    // Get it automatically from the first uninherited timing point.
                    const chartBaseMpB = getBaseMpBFromChart();
                    if (chartBaseMpB && chartBaseMpB > 0) {
                        baseMpB = chartBaseMpB;
                        console.log(`Auto-detected baseMpB: ${baseMpB}`);
                    } else {
                        // As a last resort, use a sane default (e.g., 120 BPM)
                        baseMpB = 60000 / 120; // 500ms per beat for 120 BPM
                        console.warn(`Could not detect baseMpB, falling back to default: ${baseMpB}`);
                    }
                }
                // --- END OF FIX ---

                // 3. Hide setup, show game
                document.getElementById('game-setup').classList.remove('active');
                document.getElementById('game-container').classList.add('active');

                // 4. Initialize key listeners and start the game
                initKeyListener();
                updateOffsetFromSettings(); // Ensure offset is updated one more time
                
                console.log('Starting game with chartDataFromLoader:', !!chartDataFromLoader);
                
                // Add a timeout to detect if the game gets stuck
                const gameStartTimeout = setTimeout(() => {
                    console.error('Game start timeout - game may be stuck');
                    alert('Game appears to be stuck during startup. Please refresh and try again.');
                }, 10000); // 10 second timeout
                
                try {
                    startTime();
                    console.log('Game started successfully');
                    clearTimeout(gameStartTimeout);
                } catch (error) {
                    console.error('Error in startTime():', error);
                    clearTimeout(gameStartTimeout);
                    throw error;
                }
            } catch (error) {
                console.error('Error starting game:', error);
                alert('Error starting game: ' + error.message);
            }
        }

        // --- Individual File Upload Logic ---
        document.getElementById('uploadOsu').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            try {
                // Validate file type
                if (!beatmapAPI.isValidChartFile(file)) {
                    throw new Error('Invalid chart file format. Please select a .osu or .txt file.');
                }

                const chartData = await beatmapAPI.readChartFile(file);
                
                chartDataFromLoader = chartData;
                filesLoaded.chart = true;
                showStatus('chart-status', `Loaded: ${file.name}`);
                
                if (filesLoaded.audio) {
                    document.getElementById('start-game-btn').disabled = false;
                    showGameSettings();
                }
            } catch (error) {
                showStatus('chart-status', `Error: ${error.message}`, true);
                filesLoaded.chart = false;
                chartDataFromLoader = null;
            }
        });

        document.getElementById('uploadAudio').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            try {
                // Validate file type
                if (!beatmapAPI.isValidAudioFile(file)) {
                    throw new Error('Invalid audio file format. Please select a .mp3, .wav, or .ogg file.');
                }

                const audioElement = document.getElementById('audioPlayer');
                const audioData = await beatmapAPI.readAudioFile(file);
                await beatmapAPI.setupAudioElement(audioElement, audioData);
                
                filesLoaded.audio = true;
                showStatus('audio-status', `Loaded: ${file.name}`);
                
                if (filesLoaded.chart) {
                    document.getElementById('start-game-btn').disabled = false;
                    showGameSettings();
                }
            } catch (error) {
                showStatus('audio-status', `Error: ${error.message}`, true);
                filesLoaded.audio = false;
            }
        });

        // --- OSZ File Upload Logic ---
        document.getElementById('uploadOsz').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            try {
                // Validate file type
                if (!beatmapAPI.isValidArchive(file)) {
                    throw new Error('Invalid archive file. Please select a .osz file.');
                }

                showStatus('osz-status', 'Extracting archive...');
                
                // Extract OSZ archive
                const extractedData = await beatmapAPI.extractOszArchive(file);
                oszData = extractedData;
                
                // Check if we have charts and audio
                if (extractedData.charts.length === 0) {
                    throw new Error('No valid osu!mania charts found in the archive.');
                }
                
                if (extractedData.audio.length === 0) {
                    throw new Error('No audio files found in the archive.');
                }
                
                // Show chart selection if multiple charts found
                if (extractedData.charts.length > 1) {
                    availableCharts = extractedData.charts.map((chart, index) => ({
                        ...chart,
                        index,
                        metadata: beatmapAPI.parseChartMetadata(chart.content)
                    }));
                    populateChartSelector(availableCharts);
                    document.getElementById('chart-selection').style.display = 'block';
                    showStatus('osz-status', `Extracted ${extractedData.charts.length} charts. Please select one.`);
                } else if (extractedData.charts.length === 1) {
                    // Auto-select single chart
                    await selectChart(0);
                } else {
                    throw new Error('No valid charts found in the archive.');
                }
            } catch (error) {
                showStatus('osz-status', `Error: ${error.message}`, true);
                resetOszData();
            }
        });

        function populateChartSelector(charts) {
            availableCharts = charts;
            const chartsCountElement = document.getElementById('charts-found-count');
            const selectBtn = document.getElementById('select-chart-btn');
            const selectedInfo = document.getElementById('selected-chart-info');
            
            chartsCountElement.textContent = `${charts.length} chart${charts.length > 1 ? 's' : ''} found`;
            
            // Show difficulty selection container
            document.getElementById('difficulty-selection-container').style.display = 'block';
            
            // Add click event to select button
            selectBtn.onclick = () => showChartSelectionModal(charts);
            
            // Auto-select if only one chart
            if (charts.length === 1) {
                selectChart(0);
                selectBtn.textContent = 'Chart Selected';
                selectBtn.disabled = true;
                selectBtn.style.background = 'rgba(0, 212, 255, 0.3)';
            }
        }

        function showChartSelectionModal(charts) {
            return new Promise((resolve) => {
                // Create modal overlay
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.9);
                    backdrop-filter: blur(15px);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 5000;
                    animation: fadeIn 0.3s ease;
                `;

                // Create modal dialog
                const dialog = document.createElement('div');
                dialog.style.cssText = `
                    background: rgba(0, 40, 80, 0.95);
                    border: 3px solid rgba(0, 180, 255, 0.5);
                    border-radius: 20px;
                    padding: 2rem;
                    max-width: 700px;
                    width: 90%;
                    max-height: 80vh;
                    overflow-y: auto;
                    box-shadow: 0 0 100px rgba(0, 180, 255, 0.3);
                    color: white;
                    font-family: 'Exo 2', sans-serif;
                    position: relative;
                `;

                // Build chart info
                const chartInfo = charts.map((chart, index) => {
                    const metadata = beatmapAPI.parseChartMetadata(chart.content);
                    return { index, metadata, chart };
                });

                dialog.innerHTML = `
                    <h2 style="
                        font-family: 'Orbitron', monospace;
                        font-size: 2rem;
                        font-weight: 700;
                        background: linear-gradient(45deg, #00d4ff, #00ffaa);
                        -webkit-background-clip: text;
                        background-clip: text;
                        -webkit-text-fill-color: transparent;
                        margin-bottom: 1rem;
                        text-align: center;
                    ">
                        Select Difficulty
                    </h2>
                    <p style="
                        margin-bottom: 1.5rem;
                        text-align: center;
                        color: #a0a0ff;
                        font-size: 1.1rem;
                    ">
                        ${charts.length} chart${charts.length > 1 ? 's' : ''} found. Choose your preferred difficulty.
                    </p>
                    <div id="chartList" style="margin-bottom: 1.5rem;">
                        ${chartInfo.map(chart => `
                            <div class="chart-option" data-index="${chart.index}" style="
                                border: 2px solid rgba(0, 180, 255, 0.3);
                                border-radius: 15px;
                                padding: 1.2rem;
                                margin-bottom: 1rem;
                                cursor: pointer;
                                transition: all 0.3s ease;
                                background: rgba(255, 255, 255, 0.05);
                                backdrop-filter: blur(10px);
                                position: relative;
                                overflow: hidden;
                            ">
                                <div class="chart-option-content">
                                    <div style="
                                        font-weight: bold;
                                        font-size: 1.2rem;
                                        color: #00d4ff;
                                        margin-bottom: 8px;
                                        font-family: 'Orbitron', monospace;
                                    ">
                                        ${chart.metadata.version || 'Unknown Difficulty'}
                                    </div>
                                    <div style="
                                        font-size: 0.95rem;
                                        color: #ccc;
                                        margin-bottom: 4px;
                                    ">
                                        ${chart.metadata.title || 'Unknown Title'}
                                    </div>
                                    <div style="
                                        font-size: 0.85rem;
                                        color: #80e0ff;
                                    ">
                                        by ${chart.metadata.artist || 'Unknown Artist'}
                                    </div>
                                </div>
                                <div class="chart-option-glow" style="
                                    position: absolute;
                                    top: 0;
                                    left: -100%;
                                    width: 100%;
                                    height: 100%;
                                    background: linear-gradient(90deg, 
                                        transparent, 
                                        rgba(0, 212, 255, 0.1),
                                        transparent
                                    );
                                    transition: left 0.6s ease;
                                    pointer-events: none;
                                "></div>
                            </div>
                        `).join('')}
                    </div>
                    <div style="
                        display: flex;
                        gap: 1rem;
                        justify-content: center;
                    ">
                        <button id="cancelChartSelection" class="btn secondary" style="
                            padding: 0.8rem 1.5rem;
                            font-family: 'Orbitron', monospace;
                            font-weight: 600;
                        ">
                            Cancel
                        </button>
                    </div>
                `;

                // Add hover effects and click handlers
                overlay.appendChild(dialog);
                document.body.appendChild(overlay);

                // Add CSS keyframes for fade animation
                if (!document.getElementById('chart-modal-styles')) {
                    const style = document.createElement('style');
                    style.id = 'chart-modal-styles';
                    style.textContent = `
                        @keyframes fadeIn {
                            from { opacity: 0; transform: scale(0.95); }
                            to { opacity: 1; transform: scale(1); }
                        }
                    `;
                    document.head.appendChild(style);
                }

                // Add event listeners for chart options
                const chartOptions = dialog.querySelectorAll('.chart-option');
                chartOptions.forEach(option => {
                    const glow = option.querySelector('.chart-option-glow');
                    
                    option.addEventListener('mouseenter', () => {
                        option.style.borderColor = '#00ffaa';
                        option.style.background = 'rgba(0, 255, 170, 0.1)';
                        option.style.transform = 'translateY(-2px)';
                        option.style.boxShadow = '0 8px 25px rgba(0, 255, 170, 0.2)';
                        glow.style.left = '100%';
                    });
                    
                    option.addEventListener('mouseleave', () => {
                        option.style.borderColor = 'rgba(0, 180, 255, 0.3)';
                        option.style.background = 'rgba(255, 255, 255, 0.05)';
                        option.style.transform = 'translateY(0)';
                        option.style.boxShadow = 'none';
                        glow.style.left = '-100%';
                    });
                    
                    option.addEventListener('click', () => {
                        const index = parseInt(option.dataset.index);
                        document.body.removeChild(overlay);
                        selectChart(index);
                        resolve(index);
                    });
                });

                // Cancel button
                dialog.querySelector('#cancelChartSelection').addEventListener('click', () => {
                    document.body.removeChild(overlay);
                    resolve(null);
                });

                // Close on overlay click
                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) {
                        document.body.removeChild(overlay);
                        resolve(null);
                    }
                });
            });
        }

        async function selectChart(chartIndex) {
            try {
                if (!oszData || !oszData.charts[chartIndex]) {
                    throw new Error('Chart not found.');
                }

                const selectedChart = oszData.charts[chartIndex];
                chartDataFromLoader = selectedChart.content;
                
                // Setup audio - use the first audio file found
                const audioElement = document.getElementById('audioPlayer');
                const audioFile = oszData.audio[0];
                
                audioElement.src = audioFile.url;
                audioElement.load();
                
                // Wait for audio to be ready
                await new Promise((resolve, reject) => {
                    const onCanPlay = () => {
                        audioElement.removeEventListener('canplay', onCanPlay);
                        audioElement.removeEventListener('error', onError);
                        resolve();
                    };
                    const onError = () => {
                        audioElement.removeEventListener('canplay', onCanPlay);
                        audioElement.removeEventListener('error', onError);
                        reject(new Error('Failed to load audio'));
                    };
                    audioElement.addEventListener('canplay', onCanPlay);
                    audioElement.addEventListener('error', onError);
                });
                
                filesLoaded.chart = true;
                filesLoaded.audio = true;
                
                const chartInfo = availableCharts.length > 0 ? availableCharts[chartIndex] : 
                    { metadata: beatmapAPI.parseChartMetadata(selectedChart.content) };
                
                // Update UI elements
                const selectBtn = document.getElementById('select-chart-btn');
                const selectedInfo = document.getElementById('selected-chart-info');
                const selectedTitle = document.getElementById('selected-chart-title');
                const selectedDetails = document.getElementById('selected-chart-details');
                
                selectBtn.textContent = 'Change Selection';
                selectBtn.style.background = 'rgba(0, 212, 255, 0.3)';
                
                selectedInfo.style.display = 'block';
                selectedTitle.textContent = `${chartInfo.metadata.version || 'Unknown Difficulty'}`;
                selectedDetails.textContent = `${chartInfo.metadata.title || 'Unknown Title'} - ${chartInfo.metadata.artist || 'Unknown Artist'}`;
                
                // Set background image if available
                if (oszData && oszData.images && oszData.images.length > 0) {
                    const backgroundImage = findBackgroundImage(chartInfo.metadata.title || '', oszData.images);
                    if (backgroundImage) {
                        setBackgroundImage(backgroundImage.url);
                    }
                }
                
                // Show game settings after chart selection
                showGameSettings();
                
                showStatus('osz-status', `Selected: ${chartInfo.metadata.title} [${chartInfo.metadata.version}]`);
                document.getElementById('start-game-btn').disabled = false;
                
            } catch (error) {
                showStatus('osz-status', `Error: ${error.message}`, true);
                resetOszData();
            }
        }

        function resetOszData() {
            oszData = null;
            availableCharts = [];
            
            // Clear background image
            clearBackgroundImage();
            
            // Hide difficulty selection container
            document.getElementById('difficulty-selection-container').style.display = 'none';
            
            // Reset UI elements
            const selectBtn = document.getElementById('select-chart-btn');
            const selectedInfo = document.getElementById('selected-chart-info');
            
            selectBtn.textContent = 'Select Difficulty';
            selectBtn.style.background = '';
            selectBtn.disabled = false;
            selectedInfo.style.display = 'none';
            
            // Hide game settings
            hideGameSettings();
            
            filesLoaded = { chart: false, audio: false };
            chartDataFromLoader = null;
            document.getElementById('start-game-btn').disabled = true;
        }

        // Show game settings after files are loaded
        function showGameSettings() {
            const settingsDivider = document.getElementById('settings-divider');
            const gameSettingsGrid = document.getElementById('game-settings-grid');
            const quickSettings = document.getElementById('quick-settings');
            
            // Remove inline styles and add show classes
            settingsDivider.style.display = '';
            gameSettingsGrid.style.display = '';
            quickSettings.style.display = '';
            
            settingsDivider.classList.add('show');
            gameSettingsGrid.classList.add('show');
            quickSettings.classList.add('show');
            
            // Initialize settings display
            updateGameSetupDisplays();
            updateOffsetDisplay();
        }

        // Hide game settings
        function hideGameSettings() {
            const settingsDivider = document.getElementById('settings-divider');
            const gameSettingsGrid = document.getElementById('game-settings-grid');
            const quickSettings = document.getElementById('quick-settings');
            
            // Remove show classes and hide with inline styles
            settingsDivider.classList.remove('show');
            gameSettingsGrid.classList.remove('show');
            quickSettings.classList.remove('show');
            
            settingsDivider.style.display = 'none';
            gameSettingsGrid.style.display = 'none';
            quickSettings.style.display = 'none';
        }

        // Reset upload states for individual files
        function resetUploadStates() {
            filesLoaded = { chart: false, audio: false };
            chartDataFromLoader = null;
            document.getElementById('start-game-btn').disabled = true;
            
            // Reset file status displays
            document.getElementById('chart-status').style.display = 'none';
            document.getElementById('audio-status').style.display = 'none';
            
            // Hide difficulty selection container
            document.getElementById('difficulty-selection-container').style.display = 'none';
            
            // Hide game settings
            hideGameSettings();
        }
        
        // --- Initializer ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM Content Loaded - initializing game...');
            
            const songManager = new SongManager();
            window.songManager = songManager;
            
            // Initialize settings UI
            window.gameSettingsUI = new GameSettingsUI();
            
            // Initialize wave manager in background (non-blocking)
            if (typeof WaveAnimationManager !== 'undefined') {
                console.log('WaveAnimationManager class found, initializing wave manager...');
                try {
                    window.waveManager = new WaveAnimationManager();
                    waveManager.loadPromise.then((success) => {
                        console.log('Wave manager load result:', success);
                    }).catch((error) => {
                        console.warn('Wave manager failed to load:', error);
                    });
                } catch (error) {
                    console.error('Error creating wave manager:', error);
                }
            } else {
                console.log('WaveAnimationManager class not available');
            }
            
            const songId = songManager.getSongFromURL();
            console.log('Song ID from URL:', songId);
            
            // Check if settings should be opened
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('settings') === 'true') {
                // Small delay to ensure everything is loaded
                setTimeout(() => {
                    if (window.gameSettingsUI) {
                        window.gameSettingsUI.openModal();
                    }
                }, 100);
            }
            
            if (songId) {
                console.log('Loading song:', songId);
                songManager.loadSongAndSetup(songId);
            } else {
                console.log('No song ID, entering custom mode');
                showGameSetup(null, null); // Enter custom mode
            }
        });

        // Show dolphin transition effect
        function showDolphinTransition(callback, duration = 2000) {
            const transition = document.createElement('div');
            transition.id = 'dolphin-transition';
            transition.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: linear-gradient(135deg, rgba(0, 60, 120, 0.95), rgba(0, 100, 160, 0.95));
                backdrop-filter: blur(10px);
                z-index: 9999;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                opacity: 0;
                transition: opacity 0.5s ease;
            `;
            
            const dolphinImg = document.createElement('img');
            dolphinImg.src = 'assets/dolphin.gif';
            dolphinImg.style.cssText = `
                width: 200px;
                height: 150px;
                object-fit: contain;
                animation: dolphinFloat 2s ease-in-out infinite;
                filter: drop-shadow(0 10px 20px rgba(0, 180, 255, 0.4));
            `;
            
            const text = document.createElement('p');
            text.textContent = 'Riding the wave...';
            text.style.cssText = `
                font-family: 'Orbitron', monospace;
                font-size: 1.5rem;
                color: #80E0FF;
                margin-top: 30px;
                text-shadow: 0 0 20px rgba(0, 180, 255, 0.6);
                animation: pulse 2s ease-in-out infinite;
            `;
            
            // Add dolphin float animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes dolphinFloat {
                    0%, 100% { transform: translateY(0px) rotate(-2deg); }
                    50% { transform: translateY(-15px) rotate(2deg); }
                }
            `;
            document.head.appendChild(style);
            
            transition.appendChild(dolphinImg);
            transition.appendChild(text);
            document.body.appendChild(transition);
            
            // Fade in
            setTimeout(() => {
                transition.style.opacity = '1';
            }, 50);
            
            // Execute callback and fade out
            setTimeout(() => {
                if (callback) callback();
                
                setTimeout(() => {
                    transition.style.opacity = '0';
                    setTimeout(() => {
                        if (transition.parentNode) {
                            transition.parentNode.removeChild(transition);
                        }
                    }, 500);
                }, 200);
            }, duration);
        }

        // Function to find the background image for a song
        function findBackgroundImage(songTitle, images) {
            if (!images || images.length === 0) return null;
            
            const title = songTitle.toLowerCase();
            
            // Define known background image mappings
            const backgroundMappings = {
                'bad apple': 'badapple.jpg',
                'quiet water': 'quiet water.jpg',
                'nano death': 'bg.png',
                'yeah boy': 'mania.jpg',
                'silhouette': 'BG.png',
                'senbonzakura': '1645085.jpg'
            };
            
            // First, try to find exact matches based on known mappings
            for (const [keyword, filename] of Object.entries(backgroundMappings)) {
                if (title.includes(keyword)) {
                    const found = images.find(img => 
                        img.filename.toLowerCase().includes(filename.toLowerCase())
                    );
                    if (found) return found;
                }
            }
            
            // If no exact match, try to find common background image names
            const commonNames = ['bg', 'background', 'cover', 'album'];
            for (const name of commonNames) {
                const found = images.find(img => 
                    img.filename.toLowerCase().includes(name)
                );
                if (found) return found;
            }
            
            // If still no match, return the first image
            return images[0];
        }
        
        // Function to set background image
        function setBackgroundImage(imageUrl) {
            const gameSetup = document.getElementById('game-setup');
            if (imageUrl) {
                gameSetup.style.setProperty('--bg-image', `url(${imageUrl})`);
                gameSetup.classList.add('has-background');
                // Update the CSS custom property
                const style = document.createElement('style');
                style.textContent = `
                    .game-setup.has-background::before {
                        background-image: url(${imageUrl});
                    }
                `;
                document.head.appendChild(style);
            } else {
                gameSetup.classList.remove('has-background');
            }
        }
        
        // Function to clear background image
        function clearBackgroundImage() {
            const gameSetup = document.getElementById('game-setup');
            gameSetup.classList.remove('has-background');
            // Remove any existing background style elements
            const existingStyles = document.querySelectorAll('style');
            existingStyles.forEach(style => {
                if (style.textContent.includes('game-setup.has-background::before')) {
                    style.remove();
                }
            });
        }
    </script>
</body>
</html>